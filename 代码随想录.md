

递归思想

# 做着玩

## [1436. 旅行终点站](https://leetcode.cn/problems/destination-city/)

### 哈希表

````c
typedef struct {
    char city[11];
    UT_hash_handle hh;
}hash_table,*hash_ptr;

char * destCity(char *** paths, int pathsSize, int* pathsColSize){
    hash_ptr head = NULL;
    //add all citys to the hashtable
    for(int i = 0;i < pathsSize; i++) {
        hash_ptr tmp = malloc(sizeof(hash_table));
        strcpy(tmp->city,paths[i][0]);
        HASH_ADD_STR(head,city,tmp);
    }
    //find result in cityB
    for(int i = 0;i < pathsSize; i++){ 
        hash_ptr tmp;
        HASH_FIND_STR(head,paths[i][1],tmp);
        if(tmp == NULL) {
            return paths[i][1];
        }
    }
    return NULL;
}
````



```c
struct hash_table{ 
    char name[11];//改为字符数组因为可以使用HASH_ADD_STR而非HASH_ADD_KEYSTR导致错误
    
    UT_hash_handle hh;
};
typedef struct hash_table* hash_ptr; 
char * destCity(char *** paths, int pathsSize, int* pathsColSize){
    hash_ptr head = NULL;
    hash_ptr p = NULL,temp = NULL;
    for(int i = 0;i <pathsSize;i++){
        HASH_FIND_STR(head,paths[i][0],p);
        if(p == NULL){
            p = (hash_ptr)malloc(sizeof(struct hash_table));
            strcpy(p->name,paths[i][0]);
            HASH_ADD_STR( head, name,  p );
        }    
    }
    for(int i = 0;i <pathsSize;i++){
        HASH_FIND_STR(head,paths[i][1],p);
        if(p == NULL){
           return paths[i][1];
        }    
    }
    return NULL;
}//自己写的优化过后
```

### 遍历

```c
char * destCity(char *** paths, int pathsSize, int* pathsColSize){
    char* dest = NULL; 
    for(int i = 0;i < pathsSize;i++){
        int flag = 1;//利用flag控制匹配是否成功
        //核心思想是用行程终点的每一个元素来和所有起点站进行匹配，能匹配上说明该站不是终点站
            for(int j = 0;j < pathsSize;j++){
                if(strcmp(paths[i][1],paths[j][0]) == 0) {
                    flag = 0;
                }
            }
            if ( flag ) {
                return paths[i][1];
            }
    }
    return NULL;
}
```



## **递归解题三部曲**

何为递归？程序反复调用自身即是递归。

我自己在刚开始解决递归问题的时候，总是会去纠结这一层函数做了什么，它调用自身后的下一层函数又做了什么…然后就会觉得实现一个递归解法十分复杂，根本就无从下手。

相信很多初学者和我一样，这是一个思维误区，一定要走出来。既然递归是一个反复调用自身的过程，这就说明它每一级的功能都是一样的，**因此我们只需要关注一级递归的解决过程即可。**

![img](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/hWr1UK.png)

需要关心的主要是以下三点：

1. 整个递归的终止条件。
2. 一级递归需要做什么？
3. 应该返回给上一级的返回值是什么？

**因此，也就有了我们解递归题的三部曲：**

1. **找整个递归的终止条件：递归应该在什么时候结束？**
2. **找返回值：应该给上一级返回什么信息？**
3. **本级递归应该做什么：在这一级递归中，应该完成什么任务？**

## [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

```c
int maxDepth(struct TreeNode* root){
    if(root == NULL) return 0;
    return fmax(maxDepth(root->left),maxDepth(root->right))+1;
}
```

1. **找终止条件。** 什么情况下递归结束？当然是树为空的时候，此时树的深度为0，递归就结束了。
2. **找返回值。** 应该返回什么？题目求的是树的最大深度，我们需要从每一级得到的信息自然是当前这一级对应的树的最大深度，因此我们的返回值应该是当前树的最大深度，这一步可以结合第三步来看。
3. **本级递归应该做什么。** 首先，还是强调要走出之前的思维误区，递归后我们眼里的树一定是这个样子的，看下图。此时就三个节点：root、root.left、root.right，其中根据第二步，root.left和root.right分别记录的是root的左右子树的最大深度。那么本级递归应该做什么就很明确了，自然就是在root的左右子树中选择较大的一个，再加上1就是以root为根的子树的最大深度了，然后再返回这个深度即可。
4. ![img](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/hWr724.png)

## [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

详细见链表模块

## [110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

### 自顶向下的递归

有了计算节点高度的函数，即可判断二叉树是否平衡。具体做法类似于二叉树的前序遍历，即对于当前遍历到的节点，首先计算左右子树的高度，如果左右子树的高度差是否不超过 11，再分别递归地遍历左右子节点，并判断左子树和右子树是否平衡。这是一个自顶向下的递归的过程。

```c
int maxDepth(struct TreeNode* root){
    if(root == NULL) return 0;
    return fmax(maxDepth(root->left),maxDepth(root->right))+1;
}

bool isBalanced(struct TreeNode* root){
    if(root==NULL) return true;
    return fabs(maxDepth(root->left)-maxDepth(root->right))<=1&&isBalanced(root->left)&&isBalanced(root->right);
}
```

![image-20220512115224264](C:\Users\谭宇乔\Desktop\md\代码随想录.assets\image-20220512115224264.png)

**缺点**因此对于同一个节点，函数height 会被重复调用

### 自底向上的递归

自底向上递归的做法类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 -1。如果存在一棵子树不平衡，则整个二叉树一定不平衡

```c
int height(struct TreeNode *root){
    if(root==NULL){
        return 0;
    }
    int leftHeight = height(root->left);
    int rightHeight = height(root->right);
    if(leftHeight==-1||rightHeight==-1||fabs(leftHeight-rightHeight)>1)
    {
        return -1;}
    else{
        return fmax(rightHeight,leftHeight)+1;
    }
}

bool isBalanced(struct TreeNode* root){
    return height(root)>=0;
}
```

![image-20220512115812323](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/image-20220512115812323.png)

# 数组

**定义**:数组是存放在==连续内存空间==上的==相同类型数据==的集合。

**注意**：

- **数组下标都是从0开始的。**
- **数组内存空间的地址是连续的**

**因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。**

## ==&#x270B;二分查找==

### 704. 二分查找

[力扣题目链接](https://leetcode-cn.com/problems/binary-search/)

==给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。==

__二分法前提条件__

* 数组是有序数组 

* 数组中无重复元素(因为一旦有重复元素，二分法查找到的下标可能就不是唯一的)

二分法经常写乱，主要是因为**对区间的定义没有想清楚，区间的定义就是不变量**。

要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是**循环不变量**规则。

写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。

#### 二分法第一种写法

第一种写法，我们定义 target 是在一个在左闭右闭的区间里，**也就是[left, right] （这个很重要非常重要）**。

**因为定义target在[left, right]区间，所以有如下两点：**

- while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
- if (nums [middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1

```js
//方法一
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    var left=0,right = nums.length-1;
    while(left<=right){
        let mid = left + Math.floor((right - left)/2);
        if(nums[mid]>target){
            right=mid-1;
        }else if(nums[mid]<target){
            left =mid + 1;
        }else{
            return mid;
        }
    }
    return -1;
};
```

```c
//方法一
int search(int* nums, int numsSize, int target){
    int left = 0;
    int right = numsSize-1;
    int middle = 0;
    //若left小于等于right，说明区间中元素不为0
    while(left<=right) {
        //更新查找下标middle的值
        middle = (left+right)/2;
        //此时target可能会在[left,middle-1]区间中
        if(nums[middle] > target) {
            right = middle-1;
        } 
        //此时target可能会在[middle+1,right]区间中
        else if(nums[middle] < target) {
            left = middle+1;
        } 
        //当前下标元素等于target值时，返回middle
        else if(nums[middle] == target){
            return middle;
        }
    }
    //若未找到target元素，返回-1
    return -1;
}
```

#### 二分法第二种写法

如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。

有如下两点：

- while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的
- if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]  

```js
//方法二
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    var left=0,right = nums.length;
    while(left<right){
        let mid = left + Math.floor((right - left)/2);
        if(nums[mid]>target){
            right=mid;
        }else if(nums[mid]<target){
            left =mid + 1;
        }else{
            return mid;
        }
    }
    return -1;
};
```

```c
//方法二
int search(int* nums, int numsSize, int target){
    int left=0,right=numsSize;
      int middle=0;
    while(left<right){
        middle=(left+right)/2;
        if(nums[middle]>target){
            right=middle;
        }else if(nums[middle]<target){
            left=middle+1;   
        }else{
            return middle;
        }
    }
    return -1;
}
```

### 35.搜索插入位置

[力扣题目链接](https://leetcode-cn.com/problems/search-insert-position/)

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

示例 1:

- 输入: [1,3,5,6], 5
- 输出: 2

#### **暴力求解**

```c
int searchInsert(int* nums, int numsSize, int target){
    for(int i=0;i<numsSize;i++){
        if(nums[i]>=target) return i;
    }
    return numsSize;
}
```

#### **二分查找**

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var searchInsert = function(nums, target) {
    var left = 0, right =nums.length-1;
    while(left<=right){
        let mid = left + Math.floor((right-left)/2);
        if(target<nums[mid]){
            right = mid -1;
        }else if(target > nums[mid]){
            left = mid +1;
        }else{
            return mid;
        }
    } 
    return right + 1;
};
```



```c
//方法一
int searchInsert(int* nums, int numsSize, int target){
    int left=0,right=numsSize-1;
    int middle=0;
    while(left<=right){
        middle=(left+right)/2;
        if(nums[middle]<target){
            left=middle+1;
        }else if(nums[middle]>target){
            right=middle-1;
        }else{
            return middle;
        }
    }
    // 分别处理如下四种情况
    // 目标值在数组所有元素之前  [0, -1]
    // 目标值等于数组中某一个元素  return middle;
    // 目标值插入数组中的位置 [left, right]，return  right + 1
    // 目标值在数组所有元素之后的情况 [left, right]， return right + 1
    return right+1;
}
```

```c
//方法二
int searchInsert(int* nums, int numsSize, int target){
    int left=0,right=numsSize;
    int middle=0;
    while(left<right){
        middle=(left+right)/2;
        if(nums[middle]<target){
            left=middle+1;
        }else if(nums[middle]>target){
            right=middle;
        }else{
            return middle;
        }
    }
    // 分别处理如下四种情况
    // 目标值在数组所有元素之前 [0,0)
    // 目标值等于数组中某一个元素 return middle
    // 目标值插入数组中的位置 [left, right) ，return right 即可
    // 目标值在数组所有元素之后的情况 [left, right)，return right 即可
    return right;
}
```

### 34.在排序数组中查找元素的第一个和最后一个位置

[力扣链接](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

进阶：你可以设计并实现时间复杂度为 $O(\log n)$ 的算法解决此问题吗？

示例 1：

- 输入：nums = [5,7,7,8,8,10], target = 8
- 输出：[3,4]

==成功代码==：**首先设置两个函数找到第一个和最后一个出现的target,然后返回**

```c
//力扣上的方法
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */

int searchFirst(int* nums,int numsSize,int target){
    int left = 0;
    int right = numsSize-1;
    while(left<=right){
        int mid = (right - left)/2 + left;
        if(nums[mid]<target){
            left = mid + 1;
        }else if(nums[mid]>target){
            right = mid -1;
        }else{
            // 如果当前元素已经是数组的第一个元素了，那么无需再向前看了，直接返回
            // 如果不是第一个元素，则需要看看前面是否还有元素满足条件
            if( mid == 0 || nums[mid-1]!=target) return mid;
            else right = mid -1;
        }
    }
    return -1;
}
int searchLast(int* nums,int numsSize,int target){
    int left = 0;
    int right = numsSize-1;
    while(left<=right){
        int mid = (right - left)/2 + left;
        if(nums[mid]<target){
            left = mid + 1;
        }else if(nums[mid]>target){
            right = mid - 1;
        }else{
            // 如果当前元素已经是数组的最后一个元素了，那么无需再向后看了，直接返回
            // 如果不是最后一个元素，则需要看看后面是否还有元素满足条件
            if(mid == numsSize-1 || nums[mid+1]!=target) return mid;
            else left = mid + 1;
        }
    }
    return -1;
}

int* searchRange(int* nums, int numsSize, int target, int* returnSize){
    int f=searchFirst(nums,numsSize,target);
    int l=searchLast(nums,numsSize,target);
    int *ret=malloc(sizeof(int)*2);
    ret[0]=f;
    ret[1]=l;
    *returnSize=2;
    return ret;
}

```

```c
//代码随想录方法
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int leftBorder(int *nums,int numsSize,int target){
    // 二分查找，寻找target的左边界leftBorder（不包括target）
    // 如果leftBorder没有被赋值（即target在数组范围的右边，例如数组[3,3],target为4），为了处理情况一
    int left =0,right=numsSize-1;
    int leftBorder=-2;
    int middle=0;
    while(left<=right){
        middle=(left+right)/2;
        if(nums[middle]>=target){
            right=middle-1;
            leftBorder=right;
        }else{
            left=middle+1;
        }
    }
    return leftBorder;
}
int rightBorder(int *nums,int numsSize,int target){
    
    int left =0,right=numsSize-1;
    int rightBorder=-2;
    int middle=0;
    while(left<=right){
        middle=(left+right)/2;
        if(nums[middle]>target){
             right=middle-1;
        }else{
           left=middle+1;
            rightBorder=left;
        }
    }
    return rightBorder;
}
int* searchRange(int* nums, int numsSize, int target, int* returnSize){
    int left_Border=leftBorder(nums,numsSize,target);
    int right_Border=rightBorder(nums,numsSize,target);
    int *ret;
    ret=(int *)malloc(sizeof(int)*2);
      *returnSize=2;
    if(left_Border==-2||right_Border==-2) {
        ret[0]=ret[1]=-1;
        return ret;
    }
    if(right_Border-left_Border>1) {
        ret[0]=left_Border+1;
        ret[1]=right_Border-1;
        return ret;
    }
    ret[0]=ret[1]=-1;
    return ret;
}
//报错还未找到原因
//原因找到了 因为赋值的时候使用了函数名导致数组中元素有问题
```

```js
//代码随想录方法
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var searchRange = function(nums, target) {
    const getLeftBorder=(nums,target)=>{
        let left=0,right=nums.length-1;
        let leftborder=-2;
        while(left<=right){
            let mid =left + ((right - left) >> 1);
            if(nums[mid]>=target){
                right =mid - 1;
                leftborder =right;
            }else{
                left=mid+1;
            }
        }
        return leftborder;
    }
    const getRightBorder=(nums,target)=>{
        let left=0,right=nums.length-1;
        let rightborder=-2;
        while(left<=right){
            let mid =left + ((right - left) >> 1);
            if(nums[mid]<=target){
                left=mid+1;
                rightborder =left;
            }else{
               right =mid - 1;
            }
        }
        return rightborder;
    }
    let leftborder=getLeftBorder(nums,target);
    let rightborder=getRightBorder(nums,target);
    if(leftborder==-2||rightborder==-2) return [-1,-1];
    if(rightborder-leftborder>1) return [leftborder+1,rightborder-1];
    return [-1,-1];
};
```

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var searchRange = function(nums, target) {
    //先试试普通遍历效率如何(实测只超过30%，较低)，记录第一次出现和第二次出现的位置
    let first = null,end = null;
    for(let i=0,len=nums.length;i<len;i++){
        if(nums[i] == target){
            if(first!==null){
                end = i;
            }else{
                first=i;
            }
        }
        if(nums[i]>target)break;//加上整个条件直接让时间超越97%哈哈哈
    }
    return [first==null?-1:first,end || (first!=null?first:-1)];
};

```

## ==&#x270A;移除元素==(双指针)

---

### 27.移除元素

[力扣题目链接](https://leetcode-cn.com/problems/remove-element/)

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并**原地**修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。

示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

**你不需要考虑数组中超出新长度后面的元素。**

---

#### 暴力解法

```c
int removeElement(int* nums, int numsSize, int val){
    int newnumsSize=numsSize;
    for(int i=0;i<newnumsSize;i++){
        if(nums[i]==val){
            for(int j=i+1;j<newnumsSize;j++){
                nums[j-1]=nums[j];//发现需要移除的元素将后面所有元素前移一位
            }
            i--;//因为i后面元素前移 所以i也前移
            newnumsSize--;//数组大小减一
        }
    }
    return newnumsSize;
}
```

#### 双指针法

双指针法（快慢指针法）： **通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**

![](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/008eGmZEly1gntrds6r59g30du09mnpd.gif)

**双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。**

```c
// 时间复杂度：O(n)
// 空间复杂度：O(1)
//快慢指针
int removeElement(int* nums, int numsSize, int val){
    int solwIndex = 0;
    for(int fastIndex=0;fastIndex<numsSize;fastIndex++){
        if(nums[fastIndex]!=val){
            nums[solwIndex++]=nums[fastIndex];
        }
    }
    return solwIndex;
}
```

```c
//相向双指针方法，基于元素顺序可以改变的题目描述改变了元素相对位置，确保了移动最少元素
//* 时间复杂度：O(n)
//* 空间复杂度：O(1)
//双向指针
int removeElement(int* nums, int numsSize, int val){
    int leftIndex=0,rightIndex=numsSize-1;
    while(leftIndex<=rightIndex){
        while(leftIndex<=rightIndex&&nums[leftIndex]!=val){
            ++leftIndex;
        }
        while(leftIndex<=rightIndex&&nums[rightIndex]==val){
            --rightIndex;
        }
        if(leftIndex<rightIndex){
            nums[leftIndex++]=nums[rightIndex--];
        }
        
    }
    return leftIndex;
}
```

```js
//快慢指针
/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
    let k=0;
    for(let i=0;i<nums.length;i++){
        if(nums[i]!=val){
            nums[k++]=nums[i];
        }
    }
    return k;
};
```

```js
//双向指针
/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
    let left = 0,right =nums.length-1;
    while(left<=right){
        while(left<=right&&nums[left]!=val){
            ++left;
        }
        while(left<=right&&nums[right]==val){
            --right;
        }
        if(left<right){
            nums[left++]=nums[right--];
        }
    }
    return left;
};
```

### [26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

==给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。==

==由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。==

==将最终结果插入 nums 的前 k 个位置后返回 k 。==

==不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。==

#### 快慢指针

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
    let slowIndex=0;
    for(let fastIndex=0;fastIndex<nums.length;fastIndex++){
        if(nums[fastIndex]!=nums[fastIndex+1]){
            nums[slowIndex++]=nums[fastIndex];
        }
    }
    return slowIndex;
};
```

```c
int removeDuplicates(int* nums, int numsSize){
    int slowIndex=0;
    for(int fastIndex=0;fastIndex<numsSize;fastIndex++){
        if(fastIndex+1!=numsSize&&nums[fastIndex]!=nums[fastIndex+1]){
            nums[slowIndex++]=nums[fastIndex];
        }
        if(fastIndex==numsSize-1) nums[slowIndex++]=nums[fastIndex];
    }
    return slowIndex;
}
```

```c
int removeDuplicates(int* nums, int numsSize){
    const int *p=(const int *)nums;
    const int *q=(const int *)nums;//用两个指针指向数组
    int size=0;
    if(numsSize>0) size=1;
    //p指针为输入数组中无重复值的指针 q为变化指针
    for(int i=0;i<numsSize;i++,q++){
        if(*p!=*q){
            p=q;//p追上q
            nums[size++]=*q;//q结束重复片段后的不重复值
        }
    }
    return size;
}
```



#### 其他思路

```c
int removeDuplicates(int* nums, int numsSize){
    int i=0;
    int j=1;
    int temp;
    while(j<numsSize){
        if(nums[i]==nums[j]){
            j++;//继续寻找不同元素
        }else{
            if(j==i+1){
                j++,i++;//相邻时不同，不需要交换
            }else{
            temp=nums[j];//相距大于一时需要交换
            nums[j]=nums[i+1];
            nums[i+1]=temp;
            i++,j++;
            }
        }
    }
    return i+1;
}
```

### [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

 #### 先移位后补全

```c
void moveZeroes(int* nums, int numsSize){
    int count=0;
    for(int i=0;i<numsSize;i++){
        if(nums[i]==0){
            count++;continue;
        }
        nums[i-count]=nums[i];
    }
    while(count>0){
        nums[numsSize-count]=0;
        count--;
    }
}
```

#### 双指针

**==方法一==**

```c
//利用k遍历所有元素 利用j来存储非0元素
//最后还是有补全操作
void moveZeroes(int* nums, int numsSize){
    int j=0;
    for(int k=0;k<numsSize;k++){
        if(nums[k]!=0){
            nums[j++]=nums[k];
        }
    }
    for(int i=j;i<numsSize;i++){
        nums[i]=0;
    }
}
```

**==方法二==**

---

使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。

右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。

注意到以下性质：

==左指针左边均为非零数；==

==右指针左边直到左指针处均为零==

因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。

==因此到最后，左指针到右指针剩下的都是0==

---

```c
void swap(int *a,int *b){
    int t=*a;
    *a=*b;*b=t;
}
void moveZeroes(int* nums, int numsSize){
    int left=0,right=0;
    while(right<numsSize){
        if(nums[right]!=0){
            swap(nums+left,nums+right);
            left++;
        }
        right++;
    }
}
```

## ==&#x270C;有序数组的平方==

### [977. 有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)

给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

---

示例 1：

输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]

---

#### 暴力求解

**思路** ：先整体平方，再进行排序

```js
function quickSort(arr, i, j) {
  if(i < j) {
    let left = i;
    let right = j;
    let pivot = arr[left];
    while(i < j) {
      while(arr[j] >= pivot && i < j) {  // 从后往前找比基准小的数
        j--;
      }
      if(i < j) {
        arr[i] = arr[j];
      }
      while(arr[i] <= pivot && i < j) {  // 从前往后找比基准大的数
        i++;
      }
      if(i < j) {
        arr[j] = arr[i];
      }
    }
    arr[i] = pivot;
    quickSort(arr, left, i-1);
    quickSort(arr, i+1, right);
    return arr;
  }
}

var sortedSquares = function(nums) {
    for(var i=0;i<nums.length;i++){
        nums[i]*=nums[i];
    }
    quickSort(nums,0,nums.length-1);
    return nums;
};
```

#### 双指针

数组其实是有序的， 只不过负数平方之后可能成为最大数了。

那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。

此时可以考虑双指针法了，i指向起始位置，j指向终止位置。

定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。

如果`A[i] * A[i] < A[j] * A[j]` 那么`result[k--] = A[j] * A[j];` 。

如果`A[i] * A[i] >= A[j] * A[j]` 那么`result[k--] = A[i] * A[i];` 。

---

![实例](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif)

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* sortedSquares(int* nums, int numsSize, int* returnSize){
    int *ret =malloc(sizeof(int)*numsSize);
    int k=numsSize-1;
    int j=numsSize-1;;
    for(int i=0;i<=j;){// 注意这里要i <= j，因为最后要处理两个元素
        if(nums[i]*nums[i]>=nums[j]*nums[j]){
            ret[k--]=nums[i]*nums[i];
            i++;
        }else{
            ret[k--]=nums[j]*nums[j];
            j--;
        }
    }
    *returnSize=numsSize;
    return ret;
}
//此时的时间复杂度为O(n)，相对于暴力排序的解法O(n + nlog n)还是提升不少的。
```

## ==&#x270D;长度最小的子数组==(滑动窗口)

### [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

---

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

---

示例 1：

输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。

---

#### 暴力求解

```c
int minSubArrayLen(int target, int* nums, int numsSize){
    int res=-1;
    int sum=0,sumLength=0;
    for(int i=0;i<numsSize;i++){
        sum=0;
        for(int j=i;j<numsSize;j++){
            sum+=nums[j];
            if(sum>=target){
                sumLength=j-i+1;
                if(res==-1){
                    res=sumLength;
                    break;
                }
                res=res<sumLength?res:sumLength;
                break;
            }
        }
    }
    return res==-1?0:res;
}
```

#### 滑动窗口(类似双指针)

---

所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。

![](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif)

其实从动画中可以发现滑动窗口也可以理解为==双指针法==的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。

在本题中实现滑动窗口，主要确定如下三点：

- 窗口内是什么？

>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。

- 如何移动窗口的起始位置？

>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。

- 如何移动窗口的结束位置？

>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。

解题的`关键`在于 <font size=5 color=red>窗口的起始位置如何移动</font>，如图所示：

![](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/209.长度最小的子数组.gif)

```c
int minSubArrayLen(int target, int* nums, int numsSize){
    int sum = 0;//滑动窗口总和
    int i = 0;//滑动窗口起始位置
    int res = -1;//返回最短子数组的长度
    int subLength = 0;//滑动窗口的长度
    for(int j = 0;j < numsSize;j++){
        sum+=nums[j];
        //这里使用while每次更新i(起始位置)
        while(sum>=target){
            subLength=(j-i+1);// 取子序列的长度

            if(res==-1){
                res = subLength;
            }else{
                res = res < subLength ? res :subLength;
            }
            sum -= nums[i++];// 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
        }
    }
    return res==-1 ? 0 :res;
}
```

时间复杂度：O(n) 空间复杂度：O(1)

**一些录友会疑惑为什么时间复杂度是O(n)**。

不要以为for里放一个while就以为是O(n^2)啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被被操作两次，所以时间复杂度是 2 × n 也就是O(n)。

````js
/**
 * @param {number} target
 * @param {number[]} nums
 * @return {number}
 */
var minSubArrayLen = function(target, nums) {
    let sum=0,sumLength=0;
    let res=-1;
    let i=0;
    for(var j=0;j < nums.length;j++){
        sum+=nums[j];
        while(sum>=target){
            sumLength=(j-i+1);
            if(res==-1){
                res = sumLength;
            }else{
                res = res < sumLength ? res : sumLength;
            }
            sum -= nums[i++];
        }   
    }
    return res == -1 ? 0 :res;
};
````

### [904. 水果成篮](https://leetcode-cn.com/problems/fruit-into-baskets/)

---

你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。

你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：

你只有**两个**篮子，并且每个篮子只能装**单一类型** 的水果。每个篮子能够装的水果总量没有限制。
你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。
给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。

---

示例 1：

输入：fruits = [1,2,1]
输出：3
解释：可以采摘全部 3 棵树。

---

#### 滑动窗口

这道题目是典型的滑动窗口解法
右移right指针，然后发现不满足情况开始收缩左指针
左指针收缩什么情况下停止是本题的关键。根据用例第三个实例。可以看出来，需要将数字出现的次数记录下来，然后不断减少。
直到有数字出现次数被减为0 ，此时就停止收缩了。

---

```
// 模板
for () {
    // 将新进来的右边的数据，计算进来
    // 更新数据

    // 判断窗口数据是否不满足要求了
    while (窗口数据不满要求 && left < arrSize) {
        // 移除left数据，更新窗口数据
        left++;    
    }
    right++;
}
```

```c
#define FRUIT_MAX_LEN 100001
int totalFruit(int* fruits, int fruitsSize){
    int map[FRUIT_MAX_LEN]={0};
    int cnt = 0;
    int left = 0;
    int right = 0;
    int maxlen = 0;
    for(; right < fruitsSize;right++){
        if(map[fruits[right]]==0){
            cnt++;
        }
        map[fruits[right]]++;
        if(cnt<=2){
            maxlen=fmax(maxlen,right - left + 1);
        }//记录篮子没满时的最大长度
        while(cnt > 2&&left < fruitsSize){
            map[fruits[left]]--;//篮子满了则从左边开始取水果出来，取完后cnt--
            if(map[fruits[left]]==0){
                cnt--;
            }
            left++;
        }
    }    
    
    return maxlen;
}
```

#### 类滑动窗口(较难)

[力扣题解](https://leetcode-cn.com/problems/fruit-into-baskets/solution/javaduo-zhi-zhen-jie-fa-hua-dong-chuang-rs00w/)

**解题思路**
思路

---

类似于滑动窗口的多指针解法
我们需要在遍历tree,索引为i时,不断更新以下三个指针:
当下的两个篮子第一个篮子起始索引first,
当下的两个篮子第二个篮子起始索引second,
未来的两个篮子第一个篮子的起始索引temp,
计算两个篮子中i - first + 1的最大值即可求出水果最大长度len

---

如何计算first
遍历tree记录第一个出现的篮子的索引,
当遍历到出现第三个篮子时(tree[i] != tree[first] && tree[i] != tree[second])将其更新为temp,
first = temp,保证计算len时同时出现的只有两个篮子

刷新为temp表示 将第一个篮子的起始位置改变至记录好的下一次起始位置

---

如何计算second
遍历tree记录第二个出现的篮子的索引,
当遍历到出现第三个篮子时(tree[i] != tree[first] && tree[i] != tree[second])将其更新为i,
second = i,保证计算len时同时出现的只有两个篮子

---

如何计算temp
以010123为例，
遍历完索引为3（值为1）时(只有两个篮子)，first = 0，second = 1，temp = 3。
遍历完索引为4（值为2）时(出现三个篮子)，first = 3，second = 4，temp = 4。
以010023为例，
遍历完索引为3（值为0）时(只有两个篮子)，first = 0，second = 1，temp = 2。
遍历完索引为4（值为2）时(出现三个篮子)，first = 2，second = 4，temp = 4。
有如下规律:
当下两个篮子中最后出现的篮子从后往前连续相等最长的索引,即为未来的两个篮子中第一个篮子的起始索引
0101最后出现的篮子是1索引是3,和1从后往前连续相等最长的索引还是3
0100最后出现的篮子时0索引是3,和0从后往前连续相等最长的索引是2

```c
int totalFruit(int* fruits, int fruitsSize){
    if(fruitsSize==0) return 0;
    int len = 0,first = 0,second = 0,temp = 0;
    for(int i = 0;i < fruitsSize;i++){
        //判断是否出现第三个篮子
        if(fruits[i]!=fruits[first]&&fruits[i]!=fruits[second]){
            //只有初始化时 第一个篮子和第二个篮子都为0时才相等
            //相等时出现的是第二个篮子，故不用更新first 只需要更新second
            //不相等时出现的是第三个篮子，故first second都需要更新
            if(first != second){
                first = temp;//保证计算len时同时出现的只有两个篮子
            }
            second = i;
        }
        //更新len最大值
        len = fmax(len,i - first + 1);
        //计算temp
        if(fruits[temp] != fruits[i]){
            temp = i;
        }
    }
    return len;
}
```

### [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)(困难)

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

---

注意：

对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
如果 s 中存在这样的子串，我们保证它是唯一的答案。


示例 1：

输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"

---

#### 滑动窗口

![fig1](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/76_fig1.gif)

```c
char * minWindow(char * s, char * t){
    int need[256]={0};
    int count = 0;
    for(int i=0;i<strlen(t);i++){
        need[t[i]]++;
    }
    count =strlen(t);
    int l = 0,r = 0,sublength = 0, start = 0,size = INT32_MAX;
    while(r < strlen(s)){
        char c =s[r];
        if(need[c]>0){
            count--;
        }
        need[c]--;//先把右边的字符加入窗口
        if(count==0){
            //窗口已经包含所需的全部字符
            while(l<r && need[s[l]]<0){//need元素为正表示缺少，元素为负表示多余
                //缩减窗口
                need[s[l]]++;
                l++;
            }//此时窗口符合要求
            sublength = r -l + 1; 
            if(sublength<size) {
            size = sublength;
            start = l;}//更新答案
            need[s[l]]++;//左边界右移之前需要释放need[s[l]]
            l++;
            count++;
        } 
        r++;
    }
   char * res =(char*)malloc (sizeof(char)*(size+1));
    *res = '\0' ;
    strncat(res,s+start,size) ;
    return size == INT32_MAX ? "": res;
}//用时163ms
//用时长原因找到了 ：
//没有用变量接受strlen(t) strlen(s) 导致每次都重新执行一段O(n)的求长度函数
```

```c
char * minWindow(char * s, char * t){
    int len = strlen (s) ;
    int subrlen = strlen (t) ;
    int map [256] = {0} ;
    int size = 99999 , distance ;
    int right , left ;
    int i;
    int front;

    //定义初始的数组，来记录需要的各个字母个数。
    for ( i=0 ; i<subrlen ; i++ )
    {
        map[t[i]]++;
    }

    for (right=0,left=0;right<len;right++)
    {
        //让窗口右移，直到把所有值的需要变成0，多了就变成负的。
        if (map[s[right]]>0)
        {
            map[s[right]]--;
            subrlen--;
        }else{
            map[s[right]]--;
        }

        //窗口包全时。
        if(subrlen==0)
        {
            //让左指针往右移，尽量使窗口变小。
            while( map[s[left]]<0 )
            {
                map[s[left]]++;
                left++;
            }

            distance = right - left + 1 ;
            if (distance<size)
            {
                front = left ;
                size = distance ;
            }

            //这时候left肯定是关键字。 
            map[s[left]]++ ;
            left++ ;
            subrlen++ ;
        }
    }

    if (size==99999)
    {
        return "" ;
    }

    char * res = malloc (sizeof(char)*(size+1));
    * res = '\0' ;
    strncat(res,s+front,size) ;
    return res ;
}
//用时4ms

```

用 map[] 当作哈希表，统计字符串 t 中各元素的哈希值，用 sublen 统计还未找到的字符串 t 中字母的个数。

右指针 right 从字符串 s 头移动到字符串 s 尾: s 中每个字母的对应的哈希表 -1，若字符串 s 有字符串 t 的字母（即哈希值被减一之前 >0），则 sublen-- ；

如果出现匹配的子串（即 sublen == 0 ，此时所有 t 中字母对应的哈希值都 ==0，非 t 字母对应的哈希值 <0）：更新最小匹配子串的起点 start 和长度 result ，然后 left++ 。不过在 left++ 之前要先更新窗口数据，即先将left的字母的哈希值 +1，如果加一后其值 >0，则这个字母在 t 中存在，所以要 sublen++ 。

if (result != INT32_MAX) ，找到了最小匹配字串；若未找到最小匹配子串，返回""。

## ==&#x270E;螺旋数组==

### [59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)

给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。

 ![img](https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg)

示例 1：

输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]

---

#### 模拟过程(1)# 代码随想录方法

而求解本题依然是要坚持**循环不变量**原则。

模拟顺时针画矩阵的过程:

- 填充上行从左到右
- 填充右列从上到下
- 填充下行从右到左
- 填充左列从下到上

这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开又闭的原则，这样这一圈才能按照统一的规则画下来。

那么我按照==左闭右开==的原则，来画一圈：

![螺旋矩阵](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/2020121623550681.png)

```c
int** generateMatrix(int n, int* returnSize, int** returnColumnSizes){
    int** matrix = malloc(sizeof(int*) * n);
    *returnSize = n;
    *returnColumnSizes = malloc(sizeof(int) * n);
    for (int i = 0; i < n; i++) {
        matrix[i] = malloc(sizeof(int) * n);
        memset(matrix[i], 0, sizeof(int) * n);
        (*returnColumnSizes)[i] = n;
    }
    int mid = n/2, loop = n/2;//定义中间元素的位置(奇数时存在) 循环的圈数
    int startX=0,startY=0;//定义起始坐标
    int offset = 1;//控制循环所遍历的边长
    int count = 1;//为每个空格赋值
    int i,j;
    
    while(loop--){
        i=startX,j=startY;
        for(j=startY;j<startY+n-offset;j++){//左闭右开
            matrix[i][j]=count++;
        }
        for(i=startX;i<startX+n-offset;i++){
            matrix[i][j]=count++;
        }
        for(;j>startY;j--){
            matrix[i][j]=count++;
        }
        for(;i>startX;i--){
            matrix[i][j]=count++;
        }
        startX++;
        startY++;
        offset+=2;
    }
    if(n%2){
        matrix[mid][mid]=count;
    }
    return matrix;
}
```

#### 模拟过程(2)

具体过程如下：

1、我们顺时针定义四个方向：上右下左。d = 0表示向右走，d = 1 表示向下走，d = 2表示向左走，d = 3表示向上走，方向偏移数组定义为 dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0}，如下图所示：

![img](代码随想录.assets/1631697025-jJsKmQ-file_1631697025260)

2、当前位置定义为(x,y)，使用 d = (d + 1) % 4来更改方向，那么下个要走的位置(a, b)则表示为： a = x + dx[d], b = y + dy[d]。

3、从左上角开始遍历，先往右走，走到不能走为止，然后更改到下个方向，再走到不能走为止，依次类推，遍历 n^2个格子后停止。

时间复杂度分析： 矩阵中的每个数都被遍历一次，因此时间复杂度为O(n^2),n是给定的正整数。

```c
int** generateMatrix(int n, int* returnSize, int** returnColumnSizes){
    int** res = malloc(sizeof(int*) * n);
    *returnSize = n;
    *returnColumnSizes = malloc(sizeof(int) * n);
    for (int i = 0; i < n; i++) {
        res[i] = malloc(sizeof(int) * n);
        memset(res[i], 0, sizeof(int) * n);
        (*returnColumnSizes)[i] = n;
    }
    int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};
    int x=0,y=0;//当前位置
    for(int i=1,d=0;i<=n*n;i++){
        res[x][y]=i;
        int a = x + dx[d],b = y + dy[d];
        if(a < 0 || a==n || b < 0 || b==n ||res[a][b]){//出界或者该位置已经被走过
            d = (d+1)%4;
            a = x + dx[d],b = y + dy[d];//下一个要走的位置
        }
        x = a,y = b;
    }
    return res;
}
```

## 数组模块总结

![img](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png)

# 链表

## ==&#x270F;链表基础结构==

<font size=6>单链表</font>

什么是链表，链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。

链接的入口节点称为链表的头结点也就是head。

如图所示： ![链表1](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/20200806194529815.png)<font size=6>双链表</font>

单链表中的节点只能指向节点的下一个节点。

双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。

双链表 既可以向前查询也可以向后查询。

如图所示： ![链表2](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/20200806194559317.png)

<font size=6>循环链表</font>

循环链表，顾名思义，就是链表首尾相连。

循环链表可以用来解决约瑟夫环问题。

![链表4](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/20200806194629603.png)

**链表的存储结构**

了解完链表的类型，再来说一说链表在内存中的存储方式。

数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。

链表是通过指针域的指针链接在内存中各个节点。

所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。

如图所示：

![链表3](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/20200806194613920.png)

**链表的定义**

struct ListNode {
	int val;

​	ListNode *next;

}

---

**链表的删除**

删除D节点，如图所示：

![链表-删除节点](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/20200806195114541.png)

只要将C节点的next指针 指向E节点就可以了。

那有同学说了，D节点不是依然存留在内存里么？只不过是没有在这个链表里而已。

是这样的，所以在C++里最好是再手动释放这个D节点，释放这块内存。

其他语言例如Java、Python，就有自己的内存回收机制，就不用自己手动释放了。

---

**链表的添加**

如图所示：

![链表-添加节点](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/20200806195134331.png)

可以看出链表的增添和删除都是O(1)操作，也不会影响到其他节点。

但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。

---

**性能分析**

再把链表的特性和数组的特性进行一个对比，如图所示：

![链表-链表与数据性能对比](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/20200806195200276.png)

数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。

链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。

## ==&#x269C;移除链表元素==

### [203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)

这里就涉及如下链表操作的两种方式：

- **直接使用原来的链表来进行删除操作。**
- **设置一个虚拟头结点在进行删除操作。**

#### 设置虚拟头结点

```c
struct ListNode* removeElements(struct ListNode* head, int val){
    typedef struct ListNode LNode;
    LNode * fhead,*cur;//创建一个虚拟头结点fhead
    fhead =(LNode *)malloc(sizeof(LNode));
    fhead->next = head;
    cur = fhead;//利用指针cur进行删除操作
    while(cur->next!=NULL){
        if(cur->next->val==val){
            LNode *temp=cur->next;
            cur->next=temp->next;
            free(temp);
        }else{
            cur=cur->next;
        }
    }
    head=fhead->next;
    free(fhead);
    return head;

}
```

#### 直接使用原来链表

```c
struct ListNode* removeElements(struct ListNode* head, int val){
    typedef struct ListNode ListNode;
    
     while(head!=NULL&&head->val==val){
         ListNode* temp=head;
       head=head->next;
       free(temp);
    }//当需要删除头结点时
    ListNode *cur=head;
    //需要删除非头结点时
    while(cur!=NULL&&cur->next!=NULL){
        if(cur->next->val==val){
            ListNode *temp1;
            temp1=cur->next;
            cur->next=temp1->next;
            free(temp1);
        }else{
            cur=cur->next;
        }
    }
    return head;
}
```

<font size=6 color=red>注意！！!</font>

**以下写法是错误的**

**在while循环中可能会导致对temp free多次而产生错误**

![image-20220511215849263](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/image-20220511215849263.png)

```c
typedef struct ListNode ListNode;
    ListNode* temp=head;
     while(head!=NULL&&head->val==val){ 
       head=head->next;
       free(temp);
    }//当需要删除头结点时
```

## ==&#x269D;设计链表==（考察链表基本操作)

### [707. 设计链表.](https://leetcode.cn/problems/design-linked-list/)

**注意开辟的是头结点，需要obj->next访问第一个元素**

**还有对index范围的判断**

## ==&#x269E;反转链表==

### [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。


示例 1：

输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]

---



<font size=6.3>**思路**</font>

#### 双指针法(从前往后翻转指针指向)

如果再定义一个新的链表，实现链表元素的反转，其实这是对内存空间的浪费。

其实只需要==改变链表的next指针的指向==，直接将链表反转 ，而不用重新定义一个新的链表，如图所示:

![206_反转链表](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/20210218090901207.png)

之前链表的头节点是元素1， 反转之后头结点就是元素5 ，这里并没有添加或者删除节点，仅仅是改变next指针的方向。

![img](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/008eGmZEly1gnrf1oboupg30gy0c44qp.gif)

```c
struct ListNode* reverseList(struct ListNode* head){
    struct ListNode * cur=head,*pre=NULL,*temp;
    while(cur!=NULL){
        temp = cur->next;
        cur->next=pre;
        pre=cur;
        cur=temp;
    }
    return pre;
}
```

**复杂度分析**

- 时间复杂度：O(n)，其中 *n* 是链表的长度。需要遍历链表一次。
- 空间复杂度：O(1)。

#### 递归法(采用双指针思想)

```c
struct ListNode *reverse(struct ListNode * pre,struct ListNode *cur){
    if(cur==NULL) return pre;
    struct ListNode *temp;
    temp = cur->next;
    cur->next=pre;
    return reverse(cur,temp);
    //这一步相当于
    //pre=cur;
    //cur=temp;
}

struct ListNode* reverseList(struct ListNode* head){
    return reverse(NULL,head);
}
```

#### 递归法2(从后往前改变指针指向)

```c
struct ListNode* reverseList(struct ListNode* head){
     if(head==NULL||head->next==NULL){
        return head;
    }
    struct ListNode* Last =reverseList(head->next);
    head->next->next=head;
    head->next=NULL;
    return Last;
}
```

**复杂度分析**

* 时间复杂度：O(n)，其中 n 是链表的长度。需要对链表的每个节点进行反转操作。

* 空间复杂度：O(n)，其中 n 是链表的长度。空间复杂度主要取决于递归调用的栈空间，最多为 n 层。

---

假设链表的其余部分已经被反转，现在应该如何反转它前面的部分？

假设链表为：

n~1~ ->...->n~k-1~->n~k~->n~k+1~->....->n~m~->∅

若从节点n~k+1~到n~m~已经被==反转==，而我们处在n~k~

.....n~k~->n~k+1~<-....<-n~m~

所以 n~k~.next .next=n~k~

---

```c
if (head == null || head.next == null) {
            /*
                直到当前节点的下一个节点为空时返回当前节点
                由于5没有下一个节点了，所以此处返回节点5
             */
            return head;
        }
        //递归传入下一个节点，目的是为了到达最后一个节点
        ListNode newHead = reverseList(head.next);
                /*
            第一轮出栈，head为5，head.next为空，返回5
            第二轮出栈，head为4，head.next为5，执行head.next.next=head也就是5.next=4，
                      把当前节点的子节点的子节点指向当前节点
                      此时链表为1->2->3->4<->5，由于4与5互相指向，所以此处要断开4.next=null
                      此时链表为1->2->3->4<-5
                      返回节点5
            第三轮出栈，head为3，head.next为4，执行head.next.next=head也就是4.next=3，
                      此时链表为1->2->3<->4<-5，由于3与4互相指向，所以此处要断开3.next=null
                      此时链表为1->2->3<-4<-5
                      返回节点5
            第四轮出栈，head为2，head.next为3，执行head.next.next=head也就是3.next=2，
                      此时链表为1->2<->3<-4<-5，由于2与3互相指向，所以此处要断开2.next=null
                      此时链表为1->2<-3<-4<-5
                      返回节点5
            第五轮出栈，head为1，head.next为2，执行head.next.next=head也就是2.next=1，
                      此时链表为1<->2<-3<-4<-5，由于1与2互相指向，所以此处要断开1.next=null
                      此时链表为1<-2<-3<-4<-5
                      返回节点5
            出栈完成，最终头节点5->4->3->2->1
         */
        head.next.next = head;
        head.next = null;
```

![img](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/8951bc3b8b7eb4da2a46063c1bb96932e7a69910c0a93d973bd8aa5517e59fc8.gif)

#### 妖魔化的双指针

* 原链表的头结点就是反转之后链表的尾结点，使用 head标记 .
* 定义指针 cur，初始化为 head.
* 每次都让 head 下一个结点的 next 指向 cur ，实现一次局部反转
* 局部反转完成之后，cur 和 head 的 next 指针同时 往前移动一个位置
* 循环上述过程，直至 cur 到达链表的最后一个结点 .

![img](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/1c8927d9ff605502793d81ab344dbc17e16d6db2d8dd789045f56af432079519.gif)

```c
struct ListNode* reverseList(struct ListNode* head){
    if(head==NULL){
        return NULL;}
    struct ListNode *cur=head;
    while(head->next){
        struct ListNode *temp;
        temp=head->next->next;
        head->next->next=cur;
        cur=head->next;
        head->next=temp;
    }
    return cur;
}
```

## ==&#x272C;两两交换链表中的节点==

### [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

**思路**

#### 迭代

这道题目正常模拟就可以了。

建议使用==虚拟头结点==，这样会方便很多，要不然每次针对头结点（没有前一个指针指向头结点），还要单独处理。

接下来就是交换相邻两个元素了，**此时一定要画图，不画图，操作多个指针很容易乱，而且要操作的先后顺序**

初始时，cur指向虚拟头结点，然后进行如下三步：

![24.两两交换链表中的节点1](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B91.png)

```c
struct ListNode* swapPairs(struct ListNode* head){
    struct ListNode* dummyHead=(struct ListNode*)malloc(sizeof(struct ListNode));//dummyhead 虚拟头节点
    dummyHead->next=head;
    struct ListNode * cur =dummyHead;
    struct ListNode *tmp1,*tmp2;
    while(cur->next&&cur->next->next){
        tmp1=cur->next->next;
        tmp2=cur->next->next->next;
        cur->next->next->next=cur->next;
        cur->next->next=tmp2;
        cur->next=tmp1;
        cur=cur->next->next;
    }
    return dummyHead->next;
}
```

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$

#### 递归

```c
struct ListNode* swapPairs(struct ListNode* head){
    if(head==NULL||head->next==NULL){
        return head;
    }
    struct ListNode *next=head->next;
    head->next=swapPairs(next->next);
    next->next=head;
    return next;
}
```

1. **找终止条件。** 什么情况下递归终止？没得交换的时候，递归就终止了呗。因此当链表只剩一个节点或者没有节点的时候，自然递归就终止了。
2. **找返回值。** 我们希望向上一级递归返回什么信息？由于我们的目的是两两交换链表中相邻的节点，因此自然希望交换给上一级递归的是已经完成交换处理，即已经处理好的链表。
3. **本级递归应该做什么。** 结合第二步，看下图！由于只考虑本级递归，所以这个链表在我们眼里其实也就三个节点：head、head.next、已处理完的链表部分。而本级递归的任务也就是交换这3个节点中的前两个节点，就很easy了。

![img](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/hWrva6.png)

## ==&#x272B;删除链表的倒数第N个节点==

### [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

#### 自己做的暴力解答

```c
struct ListNode* removeNthFromEnd(struct ListNode* head, int n){
    struct ListNode *cur=head,*dummyHead,*temp;
    dummyHead =(struct ListNode *)malloc(sizeof(struct ListNode));
    dummyHead ->next =head;  
    int count = 1;
    while(cur->next){
        cur =cur->next;
        count ++;
    }
    int i=1;
    if(n==count){
        temp=head;
        dummyHead->next=temp->next;
        free(temp);
        return dummyHead->next;
    }
    cur=dummyHead->next;
    while(i<count-n&&cur!=NULL){
        cur = cur->next;
        i++;
    }
    temp=cur->next;
    cur->next=temp->next;
    free(temp);
    return dummyHead->next;
}
```

#### 快慢指针

双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了

- 定义fast指针和slow指针，初始值为虚拟头结点，如图：

![img](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.png)

- fast首先走n + 1步 ，为什么是n+1呢，因为只有这样同时移动的时候slow才能指向删除节点的上一个节点（方便做删除操作），如图： ![img](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B91.png)
- fast和slow同时移动，直到fast指向末尾，如题： ![img](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B92.png)
- 删除slow指向的下一个节点，如图： ![img](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B93.png)

```c
struct ListNode* removeNthFromEnd(struct ListNode* head, int n){
    if(head==NULL) return NULL;
    struct ListNode *fast,*slow,*dummtHead,*temp;
    dummtHead =(struct ListNode *)malloc(sizeof(struct ListNode));
    dummtHead->next = head;
    fast = slow =dummtHead;
    for(int i=0;i<n+1;i++){
        fast=fast->next;//fast走n+1步让slow指向删除节点的前面
    }
    while(fast){
        fast=fast->next;
        slow=slow->next;
    }
    temp=slow->next;
    slow->next=temp->next;
    free(temp);
    return dummtHead->next;
}
```

## ==&#x272A; 链表相交==

#### [面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。

图示两个链表在节点 c1 开始相交：

![img](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/160_statement.png)

---

题目数据 保证 整个链式结构中不存在环。

注意，函数返回结果后，链表必须 保持其原始结构 。

---

#### 先对齐

```c
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    struct ListNode *curA=headA;
    struct ListNode *curB=headB;
    int len_A = 0,len_B = 0;
    while(curA!=NULL){
        curA = curA->next;
        len_A++;
    }
    while(curB!=NULL){
        curB = curB->next;
        len_B++;
    }
    curA = headA;
    curB = headB;
    if(len_B>len_A){//保证curA len_A指向最长
        int temp;
        temp = len_B;
        len_B = len_A;
        len_A = temp;
        struct ListNode * swap;
        swap = curB;
        curB = curA;
        curA =swap;
    }
    int gap = len_A -len_B;//长度差
    while(gap--&&curA!=NULL){
        curA = curA ->next;
    }//放在同一起点
    while(curA!=NULL){
        if(curA==curB){
            return curA;
        }
        curB = curB ->next;
        curA = curA ->next;
    }
    return NULL;
}
```

- 时间复杂度：$O(n + m)$
- 空间复杂度：$O(1)$

#### 双指针(难但妙)

```c
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    if(headB==NULL||headA==NULL) return NULL;
    struct ListNode *curA = headA;
    struct ListNode *curB = headB;
    while(curA!=curB){
    curA = curA==NULL ? headB :curA->next;
    curB = curB==NULL ? headA :curB->next;
    }
    return curA;
}
```

---

![image-20220513203951399](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/image-20220513203951399.png)

![image-20220513204005983](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/image-20220513204005983.png)

## ==&#x273A;环形链表II==

### [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

#### 双指针(重点是找环的起点位置)

```c
struct ListNode *detectCycle(struct ListNode *head) {
    struct ListNode *fast=head,*slow=head;
    while(fast!=NULL&&fast->next!=NULL){
        fast = fast -> next ->next;
        slow = slow -> next;
        if (slow == fast) {
        struct ListNode* index1 = fast;
        struct ListNode* index2 = head;
        while (index1 != index2) {
                index1 = index1->next;
            index2 = index2->next;
        }
         return index2; // 返回环的入口
    }
    }
    return NULL;
}
```

**如果有环，如何找到这个环的入口**

**此时已经可以判断链表是否有环了，那么接下来要找这个环的入口了。**

假设从头结点到环形入口节点 的节点数为x。 环形入口节点到 fast指针与slow指针相遇节点 节点数为y。 从相遇节点 再到环形入口节点节点数为 z。 如图所示：

![142环形链表2](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/20210318162938397.png)

那么相遇时： slow指针走过的节点数为: `x + y`， fast指针走过的节点数：`x + y + n (y + z)`，n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数A。

因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 = slow指针走过的节点数 * 2：

```
(x + y) * 2 = x + y + n (y + z)
```

两边消掉一个（x+y）: `x + y = n (y + z)`

因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。

所以要求x ，将x单独放在左面：`x = n (y + z) - y` ,

再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：`x = (n - 1) (y + z) + z` 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。

这个公式说明什么呢？

先拿n为1的情况来举例，意味着fast指针在环形里转了一圈之后，就遇到了 slow指针了。

当 n为1的时候，公式就化解为 `x = z`，

这就意味着，**从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点**。

也就是在相遇节点处，定义一个指针index1，在头结点处定一个指针index2。

让index1和index2同时移动，每次移动一个节点， 那么他们相遇的地方就是 环形入口的节点。

动画如下：

![142.环形链表II（求入口）](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/008eGmZEly1goo58gauidg30fw0bi4qr.gif)

<font size=5 color=red>**问题**</font>

可行：

```c
while(fast!=NULL&&fast->next!=NULL){
        fast = fast -> next ->next;
        slow = slow -> next;
        if(fast == slow) break;
    }
```

不可行：

**==原因==**：因为他们最开始就相同 所以不能在while里面判断

```c
while(fast != slow&&fast!=NULL&&fast->next!=NULL){
        fast = fast -> next ->next;
        slow = slow -> next;
        }
```

时间复杂度 O(N) ：第二次相遇中，慢指针须走步数 a < a + b；第一次相遇中，慢指针须走步数 a + b - x < a + b，其中 x 为双指针重合点与环入口距离；因此总体为线性复杂度；
空间复杂度 O(1) 双指针使用常数大小的额外空间。

# 哈希表

## C语言哈希表详解

[哈希表](https://blog.csdn.net/qq_45022743/article/details/123543594?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-123543594-blog-106216742.pc_relevant_antiscanv2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-123543594-blog-106216742.pc_relevant_antiscanv2&utm_relevant_index=1)

**一个简单的哈希表**

```c
#include <stdio.h>
#include <stdlib.h>
#define NUM 5
typedef struct HashList
{
    int num;
    char *data;
}HashList;
HashList * initList(){
    HashList* list = (HashList*)malloc(sizeof(HashList));
    list -> num = 0;
    list -> data = (char*)malloc(sizeof(char)*NUM);
    for(int i = 0;i<NUM;i++){
        list -> data[i] = 0;
    }
    return list; 
}
int hash(int data){
    return data % NUM;
}
void put(HashList * list, char data){
    int index = hash(data);
    printf("index = %d\n",index);
    if (list -> data[index] != 0){
        int count = 1;//线性探测法
        while (list -> data[index] != 0){
            index = hash(hash(data) + count);
            count++;
        }
    }
        list -> data[index] = data;
}
int main(){
    HashList *list = initList();
    put(list , 'A');
    put(list , 'F');
    printf("%c\n%c",list -> data[0],list -> data[1]);
}
```



首先什么是 哈希表，哈希表（英文名字为Hash table，国内也有一些算法书籍翻译为散列表，大家看到这两个名称知道都是指hash table就可以了）。

> 哈希表是根据关键码的值而直接进行访问的数据结构。

这么这官方的解释可能有点懵，其实直白来讲其实数组就是一张哈希表。

哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素，如下图所示：

![哈希表1](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/20210104234805168.png)

那么哈希表能解决什么问题呢，**一般哈希表都是用来快速判断一个元素是否出现集合里。**

例如要查询一个名字是否在这所学校里。

要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。

我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。

将学生姓名映射到哈希表上就涉及到了**hash function ，也就是哈希函数**。

## ==&#x273C;哈希函数==

哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。

哈希函数如下图所示，通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。

![哈希表2](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/2021010423484818.png)

如果hashCode得到的数值大于 哈希表的大小了，也就是大于tableSize了，怎么办呢？

此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，就要我们就保证了学生姓名一定可以映射到哈希表上了。

此时问题又来了，哈希表我们刚刚说过，就是一个数组。

如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。

接下来**哈希碰撞**登场

### 哈希碰撞

如图所示，小李和小王都映射到了索引下标 1 的位置，**这一现象叫做哈希碰撞**。

![哈希表3](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/2021010423494884.png)

一般哈希碰撞有两种解决方法， 拉链法和线性探测法。

### [ ](https://www.programmercarl.com/哈希表理论基础.html#拉链法)拉链法

刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了

![哈希表4](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/20210104235015226.png)

（数据规模是dataSize， 哈希表的大小为tableSize）

其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间

### 线性探测法

使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。

例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示：

![哈希表5](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/20210104235109950.png)

## ==&#x273B;有效的字母异位次==

### [242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

---

示例 1:

输入: s = "anagram", t = "nagaram"
输出: true

#### 哈希表

```c
bool isAnagram(char * s, char * t){
    int s_len = strlen(s);
    int t_len = strlen(t);
    if(s_len != t_len) return false;
    int map[26] = {0};
    for(int i = 0; i < s_len ;i++){
        map[s[i] - 'a']++;
        map[t[i] - 'a']--;
    }
    for(int i = 0 ;i< 26;i++){
        if(map[i] != 0){
            return false;
        }
    }
    return true;
}
```

```c
bool isAnagram(char * s, char * t){
    int s_len = strlen(s);
    int t_len = strlen(t);
    if(s_len != t_len) return false;
    int map[26] = {0},count = 0;
    for(int i = 0; i < s_len ;i++){
        map[s[i] - 'a']++;
        count++;
    }
    for(int i = 0; i < s_len ;i++){
        if(map[t[i] - 'a'] != 0){
            count --;
        }
        map[t[i] - 'a']--;
    }
    if(count != 0) return false;
    return true;
}
```

## ==&#x273F;两个数组的交集==

### [349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)

给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 

---

示例 1：

输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]

```c
int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){
    int countNum[1000] = {0};
    int curLength = nums1Size < nums1Size ? nums1Size : nums2Size;
    int *res = (int *)malloc(sizeof(int) * curLength);
    int resIndex = 0;
    for(int i = 0 ; i < nums1Size ;i++){
        countNum[nums1[i]]++;
    }
    for(int i =0 ; i < nums2Size ; i++){
        if(countNum[nums2[i]] > 0){
            res[resIndex] = nums2[i];
            resIndex ++;
            countNum[nums2[i]] = 0;
        }
    }
    * returnSize = resIndex;
    return res;
}
```

```c
var intersection = function(nums1, nums2) {
    if(nums1.length<nums2.length){
        const _ = nums1;
        nums1 = nums2;
        nums2 =_;
    }
    const nums1set = new Set(nums1);
    const retset = new Set();
    for(let i = 0;i < nums1.length;i++){
        nums1set.has(nums2[i])&&retset.add(nums2[i]);
    }
    return Array.from(retset);
}; 
```

## ==&#x273E;快乐数==

### [202. 快乐数](https://leetcode.cn/problems/happy-number/)

#### JS new Map

```c
var isHappy = function(n) {
    let m = new Map()

    const getSum =(num) => {
        let sum = 0;
        while (n) {
            sum += (n % 10) ** 2;
            n = Math.floor(n / 10)
        }
        return sum;
    }
    while (true) {
        //n出现过表示出现无限循环
        if(m.has(n)) return false
        if(n == 1) return true
        m.set(n,1);
        n = getSum(n)
    }
};
```

**map**：

 ==初始化，set 和 get==

```js
// 1 new Map(), set and get
const map1 = new Map();

map1.set('a', 1);
map1.set('b', 2);
map1.set('c', 3);
console.log(map1.get('a'));
console.log(map1.get('b'));
console.log(map1.get('c'));

```

==size==

```js
console.log(map1.size);
```

> 3

==delete==

```js
map1.delete('b');
console.log(map1.size);
```

> 2

==has==

```js
console.log(map1.has('a'));
console.log(map1.has('b'));
```

> true
>
> false

==print key,value==

```
for(const [ket,value] of map1){
	console.log(key + ':' + value);
}
for(const [key,value] of map1.entries()){
	console.log(key + ":" +value);
}
```

> a : 1
>
> c : 3

#### 哈希表(C)系统自带

```c
struct HashTable {
    int key;
    UT_hash_handle hh;
};

bool isHappy(int n){
    struct HashTable *hash = NULL;
    int sum;
    struct HashTable *first = (struct HashTable *)malloc(sizeof(struct HashTable));
    first -> key =n;
    HASH_ADD_INT(hash,key,first);
    while (1) {
        if (n == 1){
            return true;
        }
        sum = 0;
        while (n > 0) {
            sum +=(n % 10) * (n % 10);
            n /= 10;
        }
        n = sum;
        struct HashTable *s =NULL;
        HASH_FIND_INT(hash, &n,s);
        if( s ) {
            break;
        } else {
            s = (struct HashTable *)malloc(sizeof(struct HashTable));
            s -> key = n;
            HASH_ADD_INT(hash , key ,s);
        }
    }
    return false;
}
```

#### 哈希表(纯正手写)

```c
typedef struct HashNodeTag {
    int key;//num
    struct HashNodeTag *next;
}HashNode;

//计算哈希值
/*inline的作用仅仅是建议编译器做内联开展处理，而不是强制。

内联函数（inline）可以减少CPU的系统开销，并且程序的整体速度将加快，但当内联函数很大时，会有相反的作用，因此一般比较小的函数才使用内联函数。

通常，程序执行时，处理器从内存中读取代码执行。当程序中调用一个函数时，程序跳到存储器中保存函数的位置，开始读取代码执行，执行完后再返回。
为了提高速度，C语言定义了inline函数，告诉编译器把函数代码在编译时直接拷贝到程序中，这样就不用执行时另外读取函数代码。

static函数告诉编译器其他文件看不到这个函数，因此该函数只能在当前文件中被调用。static inline函数只能在当前文件中被调用，同时执行速度快，几个文件中都可以使用同样的函数名。*/
static inline int hash (int key ,int size){
    int index =key % size ;
    return (index > 0) ? index : (-index);
}
//计算每一位的平方和
static inline int calcSquareSum(int num){
    unsigned int sum = 0;
    while (num > 0){
        sum += (num % 10) * (num % 10);
        num = num / 10;
    }
    return sum;
}
#define HASH_TABLE_SIZE (32)

bool isHappy(int n){
    int sum = n;
    int index = 0;
    bool bHappy = false;
    bool bExit = false;
    //用链表方式为哈希表分配内存
    HashNode ** hashTable = (HashNode **)calloc(HASH_TABLE_SIZE,sizeof(HashNode));
    while(bExit == false){
        //检查n是否已经被计算过
        index = hash(n, HASH_TABLE_SIZE);

        HashNode ** p = hashTable + index;
        while ((*p) && (bExit == false)){
            //检查这个数字是不是被存储过，如果存储过，那么一定是循环的
            if((*p) -> key == n){
                bHappy = false;//不是快乐数
                bExit = true;//退出
            }
            //去相同下标的下一处链表
            p = &((*p) -> next);
        }
   
    //put n into hash table
    HashNode * newNode = (HashNode *)malloc(sizeof(HashNode));
    newNode -> key = n;
    newNode -> next = NULL;

    *p = newNode;
    sum = calcSquareSum(n);
    if(sum == 1){
        bHappy = true;
        bExit = true;
    }
    else{
        n = sum;
    }
    }
    return bHappy;
}
```

## ==&#x274C;两数之和==

### [1. 两数之和](https://leetcode.cn/problems/two-sum/)

```js
var twoSum = function(nums, target) {
    let hash = {};
    for(let i = 0 ; i < nums.length;i++) {
        if (hash[target - nums[i]] !== undefined){
            return [hash[target - nums[i]],i];
        }
        hash[nums[i]] = i;
    }
    return [];
};
```

```c

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
typedef struct hashTable {
    int key;
    int val;
    UT_hash_handle hh;
};

struct hashTable* hashtable;
//此处是生成一个哈希表不是重命名！！
struct hashTable* find(int ikey) {
    struct hashTable* tmp;
    HASH_FIND_INT(hashtable, &ikey, tmp);
    return tmp;
}
//不能将hashtable换成struct hashTable * 
//之前是错误理解 
void insert(int key ,int val){
    hashTable it = find(key);
    if(it == NULL){
        hashTable tmp = malloc(sizeof(hashNode));
        tmp -> key = key,tem -> val =val;
        HASH_ADD_INT(hashTable , key ,tmp);
    }else{
        it -> val =val;
    }
}

int* twoSum(int* nums, int numsSize, int target, int* returnSize){
    hashTable = NULL;
    for (int i = 0;i < numsSize; i++) {
        hashTable it =find(target - nums[i]){
            if(it != NULL){
                int *ret = malloc(sizeof(int)*2);
                ret [0] =it -> val,ret[1]=i;
                *returnSize=2;
                return ret;
            }
            insert(nums[i],i);
        }
    }
    *returnSize = 0;
    return NULL;
}
```

## ==&#x274E;四数相加==

### [454. 四数相加 II](https://leetcode.cn/problems/4sum-ii/)

给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：

0 <= i, j, k, l < n
nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0

---

#### 纯正哈希表

>思路
>
>>首先定义好哈希表的基础操作 特别是insert里不需要携带val
>>
>>然后分别遍历 `nums1 nums2`将起始数组的元素放入哈希表中 再遍历`nums3 nums4`进行比较 判断

```c
typedef struct HashTable {
    int key;
    int val;
    UT_hash_handle hh;
}HashNode,*HashTable;
HashTable hashTable;

HashTable find(int ikey){
    HashTable tmp;
    HASH_FIND_INT(hashTable,&ikey,tmp);
    return tmp;
}
void insert (int ikey ) {
    HashTable it = find(ikey);
    if (it == NULL) {
        HashTable tmp = malloc (sizeof(HashNode));
        tmp -> key = ikey, tmp ->val  = 1;
        HASH_ADD_INT(hashTable,key ,tmp);
    }else{
        it -> val++;
    }
}
int fourSumCount(int* nums1, int nums1Size, int* nums2, int nums2Size, int* nums3, int nums3Size, int* nums4, int nums4Size){
    hashTable = NULL;
    int count = 0;
    for (int i = 0;i < nums1Size ;i++) {
        for(int j = 0; j < nums2Size ;j++){
            insert(nums1[i] + nums2[j]);
        }
    }
   for (int i = 0;i < nums3Size ;i++) {
        for(int j = 0; j < nums4Size ;j++){
            HashTable it =find(0-nums3[i] - nums4[j]);
            if( it != NULL){
                count +=it -> val;
            }
        }
    }
    return count;
}
```

## ==&#x274F;赎金信==

### [383. 赎金信](https://leetcode.cn/problems/ransom-note/)

#### 模板哈希表

```c
typedef struct HashTable {
    int key;
    int val;
    UT_hash_handle hh;
}*HashTable,HashNode;

HashTable hashtable;

HashTable find (int ikey) {
    HashTable tmp;
    HASH_FIND_INT(hashtable, &ikey, tmp);
    return tmp;
}
void insert (int ikey ) {
    HashTable it = find(ikey);
    if (it == NULL) {
        HashTable tmp = malloc(sizeof(HashNode));
        tmp -> key = ikey;
        tmp -> val = 1;
        HASH_ADD_INT(hashtable,key,tmp);
    }else{
        it ->val ++;
    }
}


bool canConstruct(char * ransomNote, char * magazine){
    hashtable = NULL;
    int count = 0;
    /*值得注意 此处判断循环是否停止 我第一次采用strlen形式 但是明显可以发现这是一个O(n)级别的函数 并且每次判断都调用十分耗费时间*/
    for(int i = 0 ;ransomNote[i] != '\0';i++){
       insert(ransomNote[i]);
    }
    for(int i = 0;magazine[i] != '\0' ;i++){
        HashTable it = find(magazine[i]);
        if(it != NULL&&it ->val != 0){
            it -> val--;
        }
    } 
    bool flage = true; 
    for(int i = 0;ransomNote[i] != '\0' ; i++){
        HashTable it = find(ransomNote[i]);
        if(it -> val != 0&& it != NULL) flage = false;
    }
    return flage;
}
```

#### 数组哈希表(更合适)

```c
//力扣不能使用全局数组 不然会出现执行通过但是测试不通过
bool canConstruct(char * ransomNote, char * magazine){
    int map[26] ={0};
    for(int i = 0;ransomNote[i] !='\0';i++){
        map[ransomNote[i] - 'a']++;
    }
    for(int i = 0;magazine[i] != '\0';i ++){
        if(map[magazine[i]-'a'] > 0) 
        map[magazine[i] - 'a']--;
    }
    for(int i = 0;i < 26;i++){
        if(map[i] != 0) {
            return false;
        }
    }
    return true;
}
```

## ==&#x272C;三数之和==

### [15. 三数之和](https://leetcode.cn/problems/3sum/)

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

#### 双指针法

![15.三数之和](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif)

拿这个nums数组来举例，首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。

依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[i] b = nums[left] c = nums[right]。

接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] > 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。

如果 nums[i] + nums[left] + nums[right] < 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。

时间复杂度：$O(n^2)$。

---

```c
int cmp(const void * ptr1, const void *ptr2){
    return *((int *)ptr1) > *((int *)ptr2);
}
int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    //开辟ans数组空间
    int ** ans = (int **)malloc(sizeof(int *)* 18000);
    int ansTop = 0;//记录大小
    if (numsSize < 3) {
        *returnSize = 0;
        return ans;
    }
    //快排 使nums数组从小到大排列
    qsort(nums , numsSize ,sizeof(int) ,cmp);
    int i;
    //用for循环遍历数组 结束条件为 i<numssize - 2(因为要预留左右指针的位置)
    for (i = 0; i < numsSize - 2; i++) {
        //若当前i指向元素>0,则代表和left right相加一定大于0 直接break;
        if (nums[i] > 0) break;//所有元素均大于0 题设条件不可能成立
        //去重: i > 0 && nums[i] == nums[i-1]
        if (i > 0 && nums[i] == nums[i-1]) continue;
        //定义左右指针
        int left = i + 1;
        int right = numsSize - 1;
        //当右指针比左指针大时循环
        while (right > left) {
            //求三数之和
            int sum = nums[right] + nums[left] + nums[i];
            //若小于0 则左指针右移
            if (sum < 0) {
                left ++;
            }else if (sum > 0){
            //若大于0 则右指针左移
                right --;
            }else {
                //开辟一个大小为3的数组空间存储
                int *arr = (int *)malloc(sizeof(int) * 3);
                arr[0] = nums[i];
                arr[1] = nums[left];
                arr[2] = nums[right];
                ans[ansTop++] = arr;//将开辟的数组存入ans中
                //去重(去完仍是指向重复元素 去完后需要更新)
                while (right > left && nums[right] == nums[right - 1]) {
                    right --;
                }
                while (right > left && nums[left] == nums[left + 1]) {
                    left ++;
                }
                //更新左右指针
                left++;right--;
            }
        }
    }
    //设定返回数组大小
    *returnSize = ansTop;
    *returnColumnSizes = (int *)malloc(sizeof(int) * ansTop);
    for(int j = 0; j <ansTop; j++){
        (*returnColumnSizes)[j] = 3;
    }
    return ans;
}
```

## ==&#x272B;四数之和==

### [18. 四数之和](https://leetcode.cn/problems/4sum/)

给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：

0 <= a, b, c, d < n
a、b、c 和 d 互不相同
nums[a] + nums[b] + nums[c] + nums[d] == target
你可以按 任意顺序 返回答案 。

---

#### 双指针法

我们来回顾一下，几道题目使用了双指针法。

双指针法将时间复杂度：$O(n^2)$的解法优化为 $O(n)$的解法。也就是降一个数量级，题目如下：

- [27.移除元素(opens new window)](https://programmercarl.com/0027.移除元素.html)
- [15.三数之和(opens new window)](https://programmercarl.com/0015.三数之和.html)
- [18.四数之和(opens new window)](https://programmercarl.com/0018.四数之和.html)

操作链表：

- [206.反转链表(opens new window)](https://programmercarl.com/0206.翻转链表.html)
- [19.删除链表的倒数第N个节点(opens new window)](https://programmercarl.com/0019.删除链表的倒数第N个节点.html)
- [面试题 02.07. 链表相交(opens new window)](https://programmercarl.com/面试题02.07.链表相交.html)
- [142题.环形链表II](https://programmercarl.com/0142.环形链表II.html)

---

[15.三数之和 (opens new window)](https://programmercarl.com/0015.三数之和.html)的双指针解法是一层for循环num[i]为确定值，然后循环内有left和right下标作为双指针，找到nums[i] + nums[left] + nums[right] == 0。

四数之和的双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下标作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] == target的情况，三数之和的时间复杂度是$O(n^2)$，四数之和的时间复杂度是$O(n^3)$ 。

那么一样的道理，五数之和、六数之和等等都采用这种解法。

对于[15.三数之和 (opens new window)](https://programmercarl.com/0015.三数之和.html)双指针法就是将原本暴力$O(n^3)$的解法，降为$O(n^2)$的解法，四数之和的双指针解法就是将原本暴力$O(n^4)$的解法，降为$O(n^3)$的解法。

---

```c
因为官方增加了一个新的用例
{1000000000，1000000000，1000000000，1000000000} 0 
导致了代码出现溢出错误，是因为int的只能到表示[-2147483648,2147483647]，所以在判断
num[a]+num[b]+num[c]+num[d]<target
时会溢出。因为不想对代码进行大改了所以将表达式调整为 
nums[a]+nums[b]-target<-(nums[c]+nums[d]) 
这样子就不会溢出了。当然也可以使用long long int来表示数值，这样也不会溢出。(边界处理很重要，但学习
双指针的思想更重要~)
```

```c
int cmp(const void * ptr1,const void *ptr2) {
    return *((int*)ptr1) >*((int *)ptr2);
}
int** fourSum(int* nums, int numsSize, int target, int* returnSize, int** returnColumnSizes){
    int **ans = (int **)malloc(sizeof(int *)*18000);
    int ansTop = 0;
    if(numsSize < 4) {
        *returnSize = 0;
        return ans;
    } 
    //排序
    qsort(nums,numsSize,sizeof(int),cmp);
    for(int k = 0; k < numsSize; k++) {
        //如果这样剪枝就是错误的
        //if(nums[k] > target) return result;
        //这道题target是任意值 与三数之和不同
        if( k > 0 && nums[k] == nums[k-1]) {
            continue;//去重
        }
        //整个题逻辑与三数相加类似 只是将k+i元素的和当做之前的i元素
        for (int i = k+1; i < numsSize; i++) {
            //
            if(i > k + 1 && nums[i] == nums[i - 1]) continue;//去重
            int left = i + 1;
            int right = numsSize - 1;
            while (right > left) {
                //若直接相加判断可能会超出int限制
                if(nums[k] + nums[i] > target -(nums[left] + nums[right])) {
                    right --;
                    while (left < right && nums[right] == nums[right+1]) right--;
                }else if(nums[k] + nums[i]<target - (nums[left] + nums[right])) {
                    left ++;
                    while (left < right && nums[left] ==nums[left-1]) left++;//去重
                }else {
                    int *arr =(int *) malloc(sizeof(int) *4);
                    arr[0] = nums[k];
                    arr[1] = nums[i];
                    arr[2] = nums[left];
                    arr[3] = nums[right];
                    ans[ansTop++] = arr;
                    while (right > left && nums[right] ==nums[right - 1]) right --;
                    while (right > left && nums[left] ==nums[left + 1]) left ++; 
                    //找到答案时 双指针同时收缩
                    right--;
                    left++;
                }
            }
        }
    }
    *returnSize = ansTop;
    *returnColumnSizes = (int *)malloc(sizeof(int) *ansTop);
    for(int z = 0;z < ansTop;z++) {
        (*returnColumnSizes)[z] = 4;
    }
    return ans;
}
```

==用时提升==

```c


/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int cmp(const void *ptr1,const void*ptr2) {
    return *((int *)ptr1) > *((int*)ptr2);
}
int** fourSum(int* nums, int numsSize, int target, int* returnSize, int** returnColumnSizes){
    int** ans=(int**)malloc(sizeof(int*) * 18000);
    int ansTop = 0;
    if (numsSize < 4 ){*returnSize = 0; return ans;}
    qsort(nums,numsSize,sizeof(int),cmp);
    for(int k = 0;k < numsSize - 3;k++) {
        // if(nums[k]>target&&nums[k]>0) break;
        if((long)nums[k]+nums[k+1]+nums[k+2]+nums[k+3] > target) break;
        if(((long)nums[k] + nums[numsSize-1]+nums[numsSize-2]+nums[numsSize-3])<target) continue; 
        if (k > 0 && nums[k] == nums[k - 1]) continue;
        for (int i = k + 1;i < numsSize-2;i++) {
            if((long)nums[k]+nums[i+1]+nums[i+2]+nums[i] > target) break;
            if(((long)nums[i] + nums[numsSize-1]+nums[numsSize-2]+nums[k])<target) continue; 
            if (i > k + 1 && nums[i] == nums[i - 1]) continue;
            int left = i + 1;
            int right = numsSize - 1;
            while (left < right) {
                long long  sum = (long)nums[k] + nums[i] + nums[left] + nums[right];
                if (sum > target) right--;
                else if(sum < target) left++;
                else{
                    int *arr =(int *)malloc(sizeof(int) * 4);
                    arr[0] = nums[k];
                    arr[1] = nums[i];
                    arr[2] = nums[left];
                    arr[3] = nums[right];
                    ans[ansTop++] = arr;
                    while (left < right && nums[left] == nums[left + 1] ) left++;
                    while (left < right && nums[right] == nums[right - 1] ) right--;
                    left++;right--;
                }
            }
        }
    }
    *returnSize = ansTop;
    *returnColumnSizes = (int *)malloc(sizeof(int) * ansTop);
    for (int j = 0;j < ansTop;j++) {
        (*returnColumnSizes)[j] = 4;
    }
    return ans;
}
```

关键在于 ：

> if((long)nums[k]+nums[k+1]+nums[k+2]+nums[k+3] > target) break;
>
>  if(((long)nums[k] + nums[numsSize-1]+nums[numsSize-2]+nums[numsSize-3])<target) continue; 
>
> 选取连续四个最小数 如果最小数相加大于target 则不可能成立
>
> 选取最大的三个数与当前数据相加 如果小于target 则必须继续

#### 回溯法

![image.png](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/1645187878-yPOWXn-image.png)

```c
void backtrack(int* nums, int numsSize, int target, int* returnSize, int** returnColumnSizes, int** returnNums,long sum,int index,int deep,int *stack)
{
    //结束条件
    if (deep == 4)
    {
        if (sum == target)
        {
            returnNums[*returnSize] = (int*)malloc(sizeof(int) * 4);
            memcpy(returnNums[*returnSize], stack, sizeof(int) * 4);
            (*returnColumnSizes)[*returnSize] = 4;
            *returnSize = *returnSize +  1;
        }
        return;
    }
    else
    {
        int i;
        int a = INT_MAX;
        for (i = index + 1; i < numsSize; i++)
        {
            if (a != nums[i])
            {
                stack[deep] = nums[i];
                backtrack(nums, numsSize, target, returnSize, returnColumnSizes, returnNums, sum + nums[i], i, deep + 1, stack);
                a = nums[i];
            }
                
        }
    }

}

int compareFunc(void * a, void *b)
{
    if(*(int*)a > *(int *)b)
    {
        return 1;
    }
    return -1;
}

int** fourSum(int* nums, int numsSize, int target, int* returnSize, int** returnColumnSizes)
{
    qsort(nums, numsSize,sizeof(int),compareFunc);

    //1 <= nums.length <= 200  200的全排列 A200_4 从200个里取4个
    //200^3次方个数
    //回溯法
    int i;

    int** returnNums    = (int**)malloc(sizeof(int*)*8000000);
    *returnColumnSizes  = (int*)malloc(sizeof(int) * 8000000);
    int *stack          = (int*)malloc(sizeof(int) * 4);
    *returnSize         = 0;
    int a = INT_MAX;
    for (i = 0; i < numsSize; i++)
    {
        if (a != nums[i])
        {
            stack[0] = nums[i];
            backtrack(nums, numsSize, target, returnSize, returnColumnSizes, returnNums, nums[i], i, 1, stack);
            a = nums[i];
        }
    }
    return returnNums;
}

作者：goodgoodday
链接：https://leetcode.cn/problems/4sum/solution/si-shu-zhi-he-cyu-yan-xiang-jie-by-goodg-uign/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



# 字符串

## [344. 反转字符串](https://leetcode.cn/problems/reverse-string/)

### 双指针

![344.反转字符串](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/008eGmZEly1gp0fvi91pfg30de0akwnq.gif)

```c
void reverseString(char* s, int sSize){
    int left = 0, right = sSize - 1;
    while(right > left) {
        char temp = s[right];
        s[right--] = s[left];
        s[left++] = temp;
    } 
}
```

## [541. 反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/)

给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。

如果剩余字符少于 k 个，则将剩余字符全部反转。
如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。


示例 1：

输入：s = "abcdefg", k = 2
输出："bacdfeg"

---

### 类上题的双指针

```c
char * reverseStr(char * s, int k){
    int sLen = strlen(s);
    for (int i = 0;i < sLen; i += 2*k) {
        k = k + i >sLen ? sLen - i : k;
        int left = i;
        int right = i + k -1;
        while (right > left) {
            char temp = s[right];
            s[right--] = s[left];
            s[left++] = temp;
        } 
    }
    return s;
}
```

```js
var reverseStr = function(s, k) {
    const len =  s.length;
    let arr = s.split("");
    for (let i = 0; i < len; i += 2*k) {
        let left = i, right = k + i > len ? len - 1 : k + i - 1;
        while(right>left){[arr[left],arr[right]] =[arr[right],arr[left]];
        right--,left++;}
    }
    return arr.join("");
};
```

## [剑指 Offer 05. 替换空格](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

### 双指针

首先扩充数组到每个空格替换成"%20"之后的大小。

然后从后向前替换空格，也就是双指针法，过程如下：

i指向新长度的末尾，j指向旧长度的末尾。

![替换空格](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/e6c9d24ely1go6qmevhgpg20du09m4qp.gif)

有同学问了，为什么要从后向前填充，从前向后填充不行么？

从前向后填充就是O(n^2)的算法了，因为每次添加元素都要将添加元素之后的所有元素向后移动。

**其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。**

> 考虑到c语言就只有重新创立数组

```c
char* replaceSpace(char* s){
    int count = 0,len = 0,newlen=0,sLen =strlen(s);
    for (int i = 0 ; i < sLen; i++) {
        if(s[i] == ' ') count ++;
      
    }
    newlen = sLen + 2*count;
    char  *new = malloc(sizeof(char)*newlen + 1);
    for (int i = newlen - 1,j = sLen -1;j>=0;i --,j--) {
        if(s[j] == ' ') {
            new[i] = s[j];
        }else{
            new[i] = '0';
            new[i-1] = '2';
            new[i-2] = '%';
            i -= 2;
        }
    }
    new[newlen] = '\0';
    return new;
}

```

**注意此处 只能使用`== '  '` 若用`== " "`会算错** 

- 时间复杂度：O(n)
- 空间复杂度：O(1)

## [151. 颠倒字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)

给你一个字符串 s ，颠倒字符串中 单词 的顺序。

单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。

返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。

注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

---

示例 1：

输入：s = "the sky is blue"
输出："blue is sky the"

---

### 双指针加递归

**思路**

```
直接在原字符串上进行操作，只要将整个字符串都反转过来，那么单词的顺序就倒序了，只不过单词本身也倒序了，那么再把单词反转一下，这道题目就完成了。所以这道题共分为三步：

移除多余的空格
反转整个字符串
反转每个单词
思路比较简单，具体实现中需要重点注意一下「移除多余的空格」的操作，最直观的想法就是遍历字符串，遇到空格就执行删除操作。但是，删除数组元素的操作本身最优也就是 O(n) 的时间复杂度（参考我之前的题解：27.移除元素），再套上遍历总的时间复杂度就是 O(n^2) 了。

所以使用双指针法来移除空格，这样时间复杂度就可以降到 O(n) 了。至于反转字符串的操作，我也在 344.反转字符串 里讲过了。由于直接在原字符串上进行操作，空间复杂度为 O(1)。这样基本就把这道题做到极致了。

```

```c
void reverse(char * s , int start ,int end) {
    while (start < end) {
        char temp = s[start];
        s[start ++] = s[end];
        s[end--] = temp;
    }
}

char * reverseWords(char * s){
    int sLen = strlen(s);
    int fast = 0, slow = 0;
    //去除字符串前的空格
    while (s[fast] == ' ') {
        fast ++;
    }
    //去除字符串中部的空格
    while (fast < sLen - 1) {
        if (s[fast] == ' '&&s[fast + 1] == ' ') {
            fast ++;
        }else{
            s[slow ++] = s[fast ++];
        }
    }
    //去除字符串末尾的空格
    if (s[fast] == ' ') {
        s[slow] = '\0';
    }else {
        s[slow ++] = s[fast];
        s[slow] = '\0';
    }
    reverse(s , 0 , slow - 1);
    for (int i = 0;i < slow; i++) {
       int j = i ;
       while (j < slow && s[j] != ' '){
           j++;
       }
       reverse(s,i ,j -1);
       i = j;
    }
    return s;
}
```

## [剑指 Offer 58 - II. 左旋转字符串](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

---

示例 1：

输入: s = "abcdefg", k = 2
输出: "cdefgab"
示例 2：

输入: s = "lrloseumgh", k = 6
输出: "umghlrlose"

---

### 反序

**思路**:

> 1. 先整体反序 
> 2. 因为要将前n个放在后面，故直接对前len-n个反序
> 3. 最后对末尾的n个反序

```c
void reverse (char *s ,int start, int end ) {
    while (start < end) {
        char temp = s[start];
        s[start ++] =s[end];   
        s[end --] = temp;
        }
}
char* reverseLeftWords(char* s, int n){
    int slen = strlen(s), j = 0;
    reverse(s,0,slen - 1);
    reverse(s,0,slen - n-1);
    reverse(s,slen - n ,slen - 1);
    return s;
}
```

### 总结

此时我们已经反转好多次字符串了，来一起回顾一下吧。

在这篇文章[344.反转字符串 (opens new window)](https://programmercarl.com/0344.反转字符串.html)，第一次讲到反转一个字符串应该怎么做，使用了双指针法。

然后发现[541. 反转字符串II (opens new window)](https://programmercarl.com/0541.反转字符串II.html)，这里开始给反转加上了一些条件，当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章。

后来在[151.翻转字符串里的单词 (opens new window)](https://programmercarl.com/0151.翻转字符串里的单词.html)中，要对一句话里的单词顺序进行反转，发现先整体反转再局部反转 是一个很妙的思路。

最后再讲到本题，本题则是先局部反转再 整体反转，与[151.翻转字符串里的单词 (opens new window)](https://programmercarl.com/0151.翻转字符串里的单词.html)类似，但是也是一种新的思路。

## [28. 实现 strStr()](https://leetcode.cn/problems/implement-strstr/)

实现 strStr() 函数。

给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。

说明：

当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。

---

### 暴力求解

```c
int strStr(char * haystack, char * needle){
    if(needle[0] == '\0') return 0;
    int len1 = strlen(haystack), len2 = strlen(needle);
    for(int i = 0 ;i + len2 <=len1;i++ ) {
        bool flag = true;
        for(int j = 0 ;j < len2;j++) {
            if (haystack[i+j] != needle[j]) {
                flag = false;
                break;
            }
            
        }
        if(flag) return i;
    }
    return -1;
    
}
```

### KMP

KMP的经典思想就是:**当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。**

本篇将以如下顺序来讲解KMP，

- 什么是KMP
- KMP有什么用
- 什么是前缀表
- 为什么一定要用前缀表
- 如何计算前缀表
- 前缀表与next数组
- 使用next数组来匹配
- 时间复杂度分析
- 构造next数组
- 使用next数组来做匹配
- 前缀表统一减一 C++代码实现
- 前缀表（不减一）C++实现
- 总结

####什么是KMP

说到KMP，先说一下KMP这个名字是怎么来的，为什么叫做KMP呢。

因为是由这三位学者发明的：Knuth，Morris和Pratt，所以取了三位学者名字的首字母。所以叫做KMP

#### KMP有什么用

KMP主要应用在字符串匹配上。

KMP的主要思想是**当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。**

所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任。

其实KMP的代码不好理解，一些同学甚至直接把KMP代码的模板背下来。

没有彻底搞懂，懵懵懂懂就把代码背下来太容易忘了。

不仅面试的时候可能写不出来，如果面试官问：**next数组里的数字表示的是什么，为什么这么表示？**

估计大多数候选人都是懵逼的。

下面Carl就带大家把KMP的精髓，next数组弄清楚。

#### 什么是前缀表

写过KMP的同学，一定都写过next数组，那么这个next数组究竟是个啥呢？

next数组就是一个前缀表（prefix table）。

前缀表有什么作用呢？

**前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。**

为了清楚的了解前缀表的来历，我们来举一个例子：

要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。

请记住文本串和模式串的作用，对于理解下文很重要，要不然容易看懵。所以说三遍：

要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。

要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。

要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。

如动画所示：

![KMP详解1](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/KMP%E7%B2%BE%E8%AE%B21.gif)

动画里，我特意把 子串`aa` 标记上了，这是有原因的，大家先注意一下，后面还会说道。

可以看出，文本串中第六个字符b 和 模式串的第六个字符f，不匹配了。如果暴力匹配，会发现不匹配，此时就要从头匹配了。

但如果使用前缀表，就不会从头匹配，而是从上次已经匹配的内容开始匹配，找到了模式串中第三个字符b继续开始匹配。

此时就要问了**前缀表是如何记录的呢？**

首先要知道前缀表的任务是当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配，此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置。

那么什么是前缀表：**记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**

#### 最长公共前后缀？

文章中字符串的**前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串**。

**后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串**。

**正确理解什么是前缀什么是后缀很重要**!

那么网上清一色都说 “kmp 最长公共前后缀” 又是什么回事呢？

我查了一遍 算法导论 和 算法4里KMP的章节，都没有提到 “最长公共前后缀”这个词，也不知道从哪里来了，我理解是用“最长相等前后缀” 更准确一些。

**因为前缀表要求的就是相同前后缀的长度。**

而最长公共前后缀里面的“公共”，更像是说前缀和后缀公共的长度。这其实并不是前缀表所需要的。

所以字符串a的最长相等前后缀为0。 字符串aa的最长相等前后缀为1。 字符串aaa的最长相等前后缀为2。 等等.....。

#### 为什么一定要用前缀表

这就是前缀表，那为啥就能告诉我们 上次匹配的位置，并跳过去呢？

回顾一下，刚刚匹配的过程在下标5的地方遇到不匹配，模式串是指向f，如图： ![KMP精讲1](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/KMP%E7%B2%BE%E8%AE%B21.png)

然后就找到了下标2，指向b，继续匹配：如图： ![KMP精讲2](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/KMP%E7%B2%BE%E8%AE%B22.png)

以下这句话，对于理解为什么使用前缀表可以告诉我们匹配失败之后跳到哪里重新匹配 非常重要！

**下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面从新匹配就可以了。**

所以前缀表具有告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力。

**很多介绍KMP的文章或者视频并没有把为什么要用前缀表？这个问题说清楚，而是直接默认使用前缀表。**

#### 如何计算前缀表

接下来就要说一说怎么计算前缀表。

如图：

![KMP精讲5](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/KMP%E7%B2%BE%E8%AE%B25.png)

长度为前1个字符的子串`a`，最长相同前后缀的长度为0。（注意字符串的**前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串**；**后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串**。）

![KMP精讲6](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/KMP%E7%B2%BE%E8%AE%B26.png) 长度为前2个字符的子串`aa`，最长相同前后缀的长度为1。

![KMP精讲7](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/KMP%E7%B2%BE%E8%AE%B27.png) 长度为前3个字符的子串`aab`，最长相同前后缀的长度为0。

以此类推： 长度为前4个字符的子串`aaba`，最长相同前后缀的长度为1。 长度为前5个字符的子串`aabaa`，最长相同前后缀的长度为2。 长度为前6个字符的子串`aabaaf`，最长相同前后缀的长度为0。

那么把求得的最长相同前后缀的长度就是对应前缀表的元素，如图： ![KMP精讲8](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/KMP%E7%B2%BE%E8%AE%B28.png)

可以看出模式串与前缀表对应位置的数字表示的就是：**下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**

再来看一下如何利用 前缀表找到 当字符不匹配的时候应该指针应该移动的位置。如动画所示：

![KMP精讲2](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/KMP%E7%B2%BE%E8%AE%B22.gif)

找到的不匹配的位置， 那么此时我们要看它的前一个字符的前缀表的数值是多少。

为什么要前一个字符的前缀表的数值呢，因为要找前面字符串的最长相同的前缀和后缀。

所以要看前一位的 前缀表的数值。

前一个字符的前缀表的数值是2， 所有把下标移动到下标2的位置继续比配。 可以再反复看一下上面的动画。

最后就在文本串中找到了和模式串匹配的子串了。

#### 前缀表与next数组

很多KMP算法的时间都是使用next数组来做回退操作，那么next数组与前缀表有什么关系呢？

next数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。

为什么这么做呢，其实也是很多文章视频没有解释清楚的地方。

其实**这并不涉及到KMP的原理，而是具体实现，next数组即可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。**

后面我会提供两种不同的实现代码，大家就明白了。

#### 使用next数组来匹配

**以下我们以前缀表统一减一之后的next数组来做演示**。

有了next数组，就可以根据next数组来 匹配文本串s，和模式串t了。

注意next数组是新前缀表（旧前缀表统一减一了）。

匹配过程动画如下：

![KMP精讲4](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/KMP%E7%B2%BE%E8%AE%B24.gif)

#### 时间复杂度分析

其中n为文本串长度，m为模式串长度，因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出匹配的过程是O(n)，之前还要单独生成next数组，时间复杂度是O(m)。所以整个KMP算法的时间复杂度是O(n+m)的。

暴力的解法显而易见是O(n × m)，所以**KMP在字符串匹配中极大的提高的搜索的效率。**

为了和力扣题目28.实现strStr保持一致，方便大家理解，以下文章统称haystack为文本串, needle为模式串。

都知道使用KMP算法，一定要构造next数组。

#### 构造next数组

我们定义一个函数getNext来构建next数组，函数参数为指向next数组的指针，和一个字符串。 代码如下：

```text
void getNext(int* next, const string& s)
```

**构造next数组其实就是计算模式串s，前缀表的过程。** 主要有如下三步：

1. 初始化
2. 处理前后缀不相同的情况
3. 处理前后缀相同的情况

接下来我们详解详解一下。

1. 初始化：

定义两个指针i和j，j指向前缀末尾位置，i指向后缀末尾位置。

然后还要对next数组进行初始化赋值，如下：

```cpp
int j = -1;
next[0] = j;
```

j 为什么要初始化为 -1呢，因为之前说过 前缀表要统一减一的操作仅仅是其中的一种实现，我们这里选择j初始化为-1，下文我还会给出j不初始化为-1的实现代码。

next[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j）

所以初始化next[0] = j 。

1. 处理前后缀不相同的情况

因为j初始化为-1，那么i就从1开始，进行s[i] 与 s[j+1]的比较。

所以遍历模式串s的循环下标i 要从 1开始，代码如下：

```cpp
for (int i = 1; i < s.size(); i++) {
```

如果 s[i] 与 s[j+1]不相同，也就是遇到 前后缀末尾不相同的情况，就要向前回退。

怎么回退呢？

next[j]就是记录着j（包括j）之前的子串的相同前后缀的长度。

那么 s[i] 与 s[j+1] 不相同，就要找 j+1前一个元素在next数组里的值（就是next[j]）。

所以，处理前后缀不相同的情况代码如下：

```cpp
while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了
    j = next[j]; // 向前回退
}
```



1. 处理前后缀相同的情况

如果 s[i] 与 s[j + 1] 相同，那么就同时向后移动i 和j 说明找到了相同的前后缀，同时还要将j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。

代码如下：

```text
if (s[i] == s[j + 1]) { // 找到相同的前后缀
    j++;
}
next[i] = j;
```



最后整体构建next数组的函数代码如下：

```cpp
void getNext(int* next, const string& s){
    int j = -1;
    next[0] = j;
    for(int i = 1; i < s.size(); i++) { // 注意i从1开始
        while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了
            j = next[j]; // 向前回退
        }
        if (s[i] == s[j + 1]) { // 找到相同的前后缀
            j++;
        }
        next[i] = j; // 将j（前缀的长度）赋给next[i]
    }
}
```



代码构造next数组的逻辑流程动画如下：

![KMP精讲3](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/KMP%E7%B2%BE%E8%AE%B23.gif)

得到了next数组之后，就要用这个来做匹配了。

#### 使用next数组来做匹配

在文本串s里 找是否出现过模式串t。

定义两个下标j 指向模式串起始位置，i指向文本串起始位置。

那么j初始值依然为-1，为什么呢？ **依然因为next数组里记录的起始位置为-1。**

i就从0开始，遍历文本串，代码如下：

```cpp
for (int i = 0; i < s.size(); i++) 
```

接下来就是 s[i] 与 t[j + 1] （因为j从-1开始的） 进行比较。

如果 s[i] 与 t[j + 1] 不相同，j就要从next数组里寻找下一个匹配的位置。

代码如下：

```cpp
while(j >= 0 && s[i] != t[j + 1]) {
    j = next[j];
}
```

如果 s[i] 与 t[j + 1] 相同，那么i 和 j 同时向后移动， 代码如下：

```cpp
if (s[i] == t[j + 1]) {
    j++; // i的增加在for循环里
}
```

如何判断在文本串s里出现了模式串t呢，如果j指向了模式串t的末尾，那么就说明模式串t完全匹配文本串s里的某个子串了。

本题要在文本串字符串中找出模式串出现的第一个位置 (从0开始)，所以返回当前在文本串匹配模式串的位置i 减去 模式串的长度，就是文本串字符串中出现模式串的第一个位置。

代码如下：

```cpp
if (j == (t.size() - 1) ) {
    return (i - t.size() + 1);
}
```

那么使用next数组，用模式串匹配文本串的整体代码如下：

```cpp
int j = -1; // 因为next数组里记录的起始位置为-1
for (int i = 0; i < s.size(); i++) { // 注意i就从0开始
    while(j >= 0 && s[i] != t[j + 1]) { // 不匹配
        j = next[j]; // j 寻找之前匹配的位置
    }
    if (s[i] == t[j + 1]) { // 匹配，j和i同时向后移动
        j++; // i的增加在for循环里
    }
    if (j == (t.size() - 1) ) { // 文本串s里出现了模式串t
        return (i - t.size() + 1);
    }
}
```

---

> 求next数组
>
> 1. 初始化
> 2. 前后缀不相同
> 3. 前后缀相同
> 4. next

```c
i 后缀末尾 j前缀末尾

j = 0; next[0] = j;

for (i = 1 ;i < s. size();i++) {

​	while (j>0&&s[i]!=s[j]){

​		j = next[j-1];

}

	if(s[i]==s[j])j++; 
    next[i] = j;

}

}
```

### KMP代码实现



```c
int strStr(char * haystack, char * needle){
    int n = strlen(haystack), m = strlen(needle);
    if(m==0) return 0;
    int next[m];
    int i,j = 0;
    next[0]  = j;
    for (i = 1 ; i < m; i++) {
        while (j > 0&& needle[i] != needle[j]) {
            j = next[j-1];
        }
        if (needle[i] == needle[j]) j++;
        next[i] = j;
    }//初始化next数组
    for (i = 0,j = 0;i < n;i ++) {
        while (j > 0 && haystack[i] != needle[j]) {
            j = next[j - 1];
        }
        if (haystack[i] == needle[j]) j++;//如果相等同时++ (i在循环里++)
        if (j == m) {
            return i - m + 1;
        }
    } 
    return -1;
    
}
```

## [459. 重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/)

### next数组的规律

**正确**

![image-20220602160809153](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/image-20220602160809153.png)

![image-20220602160815681](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/image-20220602160815681.png)

![image-20220602160835357](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/image-20220602160835357.png)

![image-20220602160841427](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/image-20220602160841427.png)

**不正确**

![image-20220602160951302](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/image-20220602160951302.png)

![image-20220602160957679](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/image-20220602160957679.png)

---

### 利用kmp

```c
bool repeatedSubstringPattern(char * s){
    int slen = strlen(s);
    int next[slen];
    next[0] = 0;
    for (int i = 1, j = 0;i < slen;i ++) {
        while (j > 0 && s[i] != s[j]) {
            j = next[j-1];
        }
        if (s[i] == s[j]) j++;
        next[i] = j;
    }//初始化next数组
    if (slen %(slen -next[slen - 1]) == 0&& next[slen-1]!=0) {return true;}
    return false;
}
```

# 双指针大专题

## [27. 移除元素](https://leetcode.cn/problems/remove-element/)(数组章节)

## [344. 反转字符串](https://leetcode.cn/problems/reverse-string/)(字符串章节)

## [剑指 Offer 05. 替换空格](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)(字符串章节)

## [151. 颠倒字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)(字符串章节)

## ==[206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)(链表章节)==

```c
struct ListNode* reverseList(struct ListNode* head){
    struct ListNode * pre = NULL, *cur =head,*temp;
    while (cur) {
        temp = cur->next;
        cur -> next = pre;
        pre = cur;
        cur = temp;
    }
    return pre;
}
```

## [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

```c
struct ListNode* removeNthFromEnd(struct ListNode* head, int n){
    if (head == NULL) return NULL;
    struct ListNode *fast ,*slow, * dummyHead,* temp;
    dummyHead = (struct ListNode *)malloc(sizeof(struct ListNode));
    dummyHead -> next = head;
    fast = slow =dummyHead;
    for (int i = 0 ; i < n + 1; i++){
        fast = fast -> next;
    }
    while (fast) {
        fast = fast -> next;
        slow = slow -> next; 
    }
    temp = slow -> next;
    slow -> next = temp -> next;
    free(temp);
    return dummyHead -> next;

}
```

## [面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

**方法一**

```c
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    if (headA == NULL || headB == NULL) return NULL;
    struct ListNode * curA = headA, *curB = headB;
    while (curA != curB) {
        curA = curA == NULL ? headB : curA -> next;
        curB = curB == NULL ? headA : curB -> next;
    }
    return curA;
}
```

**方法二(先对齐 后共同移动)**

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    int lenA = 0,lenB = 0;
    struct ListNode *curA = headA,*curB = headB,*temp;
    while (curA) {
        lenA ++;
        curA = curA -> next;
    }
    while (curB) {
        lenB++;
        curB = curB -> next;
    }
    curA = headA,curB = headB;
    if (lenA < lenB) {
        temp = curB;
        curB = curA;
        curA =temp;
    }
    int del = lenA < lenB ? lenB - lenA : lenA - lenB;
    while (del > 0) {
        del --;
        curA = curA -> next;
    }
    while (curA != curB && curA != NULL) {
        curA = curA -> next;
        curB = curB -> next;
    }
    return curA;
}
```

## [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

```c
struct ListNode *detectCycle(struct ListNode *head) {
    struct ListNode * slow = head, *fast = head;
    while (fast != NULL && fast -> next != NULL) {
        fast = fast -> next -> next;
        slow = slow -> next;
        if (slow == fast) break;
    }
       if ( fast == NULL || fast -> next == NULL) return NULL;
    //if ( fast -> next == NULL|| fast == NULL ) return NULL; 如果使用这个判别方法 当fast等于NULL时 无法进行第一个判断会出错
    slow = head;//让slow指针回到头结点
    //此时slow fast走相同的步数就会回到进入环的结点
    while (slow != fast) {
        slow = slow -> next;
        fast = fast -> next;
    }
    return slow;
}
```

## ==[15. 三数之和](https://leetcode.cn/problems/3sum/)==

# 栈和队列

## [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

```c
数组栈
typedef struct {
    int stackInTop,stackOutTop;
    int stackIn[100],stackOut[100];
} MyQueue;


MyQueue* myQueueCreate() { 
    MyQueue *newQ = (MyQueue*)malloc(sizeof(MyQueue));
    newQ -> stackInTop = 0;
    newQ -> stackOutTop = 0;
    return newQ;
}

void myQueuePush(MyQueue* obj, int x) {
    obj->stackIn[obj->stackInTop++] = x;
}

int myQueuePop(MyQueue* obj) {	
    int stackInTop = obj -> stackInTop,stackOutTop = obj ->stackOutTop;
    //若输出栈为空
    if (stackOutTop == 0) {
        while (stackInTop > 0) {
            obj->stackOut[stackOutTop++] = obj -> stackIn[--stackInTop];
        }
    }
    //将输出栈的栈顶元素取出(因为输出栈为空时我们进行了逆序操作)
    int top = obj -> stackOut[--stackOutTop];
    while (stackOutTop > 0) {
        obj -> stackIn[stackInTop++] = obj -> stackOut[--stackOutTop];
    }
    obj -> stackInTop = stackInTop;
    obj -> stackOutTop =stackOutTop;
    return top;
}

int myQueuePeek(MyQueue* obj) {
    return obj->stackIn[0];
}

bool myQueueEmpty(MyQueue* obj) {
    return obj -> stackOutTop == 0 && obj -> stackInTop == 0;
}

void myQueueFree(MyQueue* obj) {
    obj -> stackInTop =0;
    obj -> stackOutTop = 0;
}

/**
 * Your MyQueue struct will be instantiated and called as such:
 * MyQueue* obj = myQueueCreate();
 * myQueuePush(obj, x);
 
 * int param_2 = myQueuePop(obj);
 
 * int param_3 = myQueuePeek(obj);
 
 * bool param_4 = myQueueEmpty(obj);
 
 * myQueueFree(obj);
*/
```

```c
typedef struct {
    int* stk;
    int stkSize;
    int stkCapacity;
} Stack;

Stack* stackCreate(int cpacity) {
    Stack* ret = malloc(sizeof(Stack));
    ret->stk = malloc(sizeof(int) * cpacity);
    ret->stkSize = 0;
    ret->stkCapacity = cpacity;
    return ret;
}

void stackPush(Stack* obj, int x) {
    obj->stk[obj->stkSize++] = x;
}

void stackPop(Stack* obj) {
    obj->stkSize--;
}

int stackTop(Stack* obj) {
    return obj->stk[obj->stkSize - 1];
}

bool stackEmpty(Stack* obj) {
    return obj->stkSize == 0;
}

void stackFree(Stack* obj) {
    free(obj->stk);
}

typedef struct {
    Stack* inStack;
    Stack* outStack;
} MyQueue;

MyQueue* myQueueCreate() {
    MyQueue* ret = malloc(sizeof(MyQueue));
    ret->inStack = stackCreate(100);
    ret->outStack = stackCreate(100);
    return ret;
}

void in2out(MyQueue* obj) {
    while (!stackEmpty(obj->inStack)) {
        stackPush(obj->outStack, stackTop(obj->inStack));
        stackPop(obj->inStack);
    }
}

void myQueuePush(MyQueue* obj, int x) {
    stackPush(obj->inStack, x);
}

int myQueuePop(MyQueue* obj) {
    if (stackEmpty(obj->outStack)) {
        in2out(obj);
    }
    int x = stackTop(obj->outStack);
    stackPop(obj->outStack);
    return x;
}

int myQueuePeek(MyQueue* obj) {
    if (stackEmpty(obj->outStack)) {
        in2out(obj);
    }
    return stackTop(obj->outStack);
}

bool myQueueEmpty(MyQueue* obj) {
    return stackEmpty(obj->inStack) && stackEmpty(obj->outStack);
}

void myQueueFree(MyQueue* obj) {
    stackFree(obj->inStack);
    stackFree(obj->outStack);
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/implement-queue-using-stacks/solution/yong-zhan-shi-xian-dui-lie-by-leetcode-s-xnb6/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```

//先构造栈
typedef struct  {
    int *stk;
    int stkSize;
    int stkCapacity;
}Stack;
Stack * stackCreate(int capacity) {
    Stack *ret = (Stack*)malloc(sizeof(Stack));
    ret -> stk = (int *) malloc(sizeof(int)*capacity);
    ret -> stkSize = 0;
    ret -> stkCapacity = capacity;
    return ret;
}
 void stackPush(Stack *obj,int x ){ 
     obj -> stk[obj->stkSize++] = x;
 }
int stackPop(Stack*obj ){
    return obj->stk[--obj->stkSize];
}
bool stackEmpty(Stack* obj) {
    return obj -> stkSize == 0;
}
void stackFree(Stack *obj) {
    free(obj->stk);
}
typedef struct {
    Stack * inStack;
    Stack * outStack;
} MyQueue;


MyQueue* myQueueCreate() {
    MyQueue *ret = (MyQueue*)malloc(sizeof(MyQueue));
    ret -> inStack = stackCreate(100);
    ret -> outStack = stackCreate(100);
    return ret;
}

void exchange(MyQueue *obj) {
    while (!stackEmpty(obj->inStack)){
        stackPush(obj -> outStack,stackPop(obj -> inStack));
    }
}
void myQueuePush(MyQueue* obj, int x) {
    stackPush(obj -> inStack, x);
}

int myQueuePop(MyQueue* obj) {
    if (stackEmpty(obj->outStack)) {
        exchange(obj);
    }
    int x =  obj->outStack->stk[(obj->outStack)->stkSize-1];
    stackPop(obj->outStack);
    exchange(obj);
    return x;
}

int myQueuePeek(MyQueue* obj) {
    return obj -> inStack->stk[0];
}   

bool myQueueEmpty(MyQueue* obj) {
    return stackEmpty(obj->inStack) && stackEmpty(obj->outStack);
}

void myQueueFree(MyQueue* obj) {
    stackFree(obj->inStack);
    stackFree(obj->outStack);
}

/**
 * Your MyQueue struct will be instantiated and called as such:
 * MyQueue* obj = myQueueCreate();
 * myQueuePush(obj, x);
 
 * int param_2 = myQueuePop(obj);
 
 * int param_3 = myQueuePeek(obj);
 
 * bool param_4 = myQueueEmpty(obj);
 
 * myQueueFree(obj);
*/
```



## [225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

###  用两个队列

>![image-20220630153253233](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/image-20220630153253233.png)
>
>![fig1](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/225_fig1.gif)

```c
//利用两个队列来表示栈 一个用来存储一个用来接受
//问题1 ： 栈的表示方式
//https://leetcode.cn/problems/implement-stack-using-queues/solution/yong-dui-lie-shi-xian-zhan-by-leetcode-solution/
#define LEN 20
typedef struct {
    int *data;
    int rear;
    int head;
    int size;
} Queue;
typedef struct {
    Queue *queue1,*queue2;
}MyStack;

Queue *initQueue(int k) {
    Queue *obj = (Queue *)malloc(sizeof(Queue));
    obj -> data = (int *)malloc(sizeof(int) *k);
    obj -> head = -1;
    obj -> rear = -1;
    obj -> size = k;
    return obj;
}

void enQueue(Queue *obj, int e) {
    if (obj -> head == -1) {
        obj -> head =0;
    }
    obj -> rear = (obj ->rear + 1)% obj -> size;
    obj -> data[obj -> rear] = e;
}//插入队列

int deQueue(Queue *obj) {
    int a = obj -> data[obj -> head];
    if (obj -> head == obj -> rear) {
        obj -> rear = -1;
        obj -> head = -1;
        return a; 
    }
    obj -> head = (obj -> head + 1) % obj->size;
    return a;
}

int isEmpty(Queue *obj) {
    return obj -> head == -1;
}

MyStack* myStackCreate() {
    MyStack *obj = (MyStack *)malloc(sizeof(MyStack));
    obj -> queue1 = initQueue(LEN);
    obj -> queue2 = initQueue(LEN);
    return obj;
}

void myStackPush(MyStack* obj, int x) {
    if (isEmpty(obj -> queue1)) {
        enQueue(obj->queue2,x);
    }else{
        enQueue(obj->queue1,x);
    }
}

int myStackPop(MyStack* obj) {
    if (isEmpty(obj->queue1)) {
        while (obj ->queue2->rear !=obj->queue2->head) {
            enQueue(obj->queue1,deQueue(obj->queue2));
        }
        return deQueue(obj->queue2);//返回栈底元素
    }
    while (obj->queue1->head != obj->queue1->rear) {
        enQueue(obj->queue2,deQueue(obj->queue1));
    }
    return deQueue(obj->queue1);
}

int myStackTop(MyStack* obj) {
    if(isEmpty(obj->queue1)) {
        return obj->queue2->data[obj->queue2->rear];
    }
    return obj->queue1->data[obj->queue1->rear];
}

bool myStackEmpty(MyStack* obj) {
    if (obj ->queue1->head==-1&&obj->queue2->head==-1) {
        return true;
    }
    return false;
}

void myStackFree(MyStack* obj) {
    free(obj->queue1->data);
    obj->queue1->data=NULL;
     free(obj->queue1);
    obj->queue1 = NULL;
    free(obj->queue2->data);
    obj->queue2->data = NULL;
    free(obj->queue2);
    obj->queue2 = NULL;
    free(obj);
    obj = NULL;
}

/**
 * Your MyStack struct will be instantiated and called as such:
 * MyStack* obj = myStackCreate();
 * myStackPush(obj, x);
 
 * int param_2 = myStackPop(obj);
 
 * int param_3 = myStackTop(obj);
 
 * bool param_4 = myStackEmpty(obj);
 
 * myStackFree(obj);
*/
```

### 用一个队列

方法一使用了两个队列实现栈的操作，也可以使用一个队列实现栈的操作。

使用一个队列时，为了满足栈的特性，即最后入栈的元素最先出栈，同样需要满足队列前端的元素是最后入栈的元素。

==入栈操作时，首先获得入栈前的元素个数 n，然后将元素入队到队列，再将队列中的前 n 个元素（即除了新入栈的元素之外的全部元素）依次出队并入队到队列，此时队列的前端的元素即为新入栈的元素，且队列的前端和后端分别对应栈顶和栈底。==

由于每次入栈操作都确保队列的前端元素为栈顶元素，因此出栈操作和获得栈顶元素操作都可以简单实现。出栈操作只需要移除队列的前端元素并返回即可，获得栈顶元素操作只需要获得队列的前端元素并返回即可（不移除元素）。

由于队列用于存储栈内的元素，判断栈是否为空时，只需要判断队列是否为空即可



![fig2](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/225_fig2.gif)

```c

#define LEN 20
typedef struct {
    int *data;
    int front;
    int rear;
    int len;
}Queue;

Queue* initQueue(int k) {
    Queue *q =(Queue*)malloc(sizeof(Queue));
    q->data = (int*)malloc(sizeof(int) * k);
    q->rear = q->front = -1;
    q->len = k;
    return q;
}

void enQueue(Queue *obj,int k) {
    if(obj->front == -1){
        obj->front = 0;
    }
    obj -> rear = (obj->rear+1)%obj->len;
    obj -> data[obj->rear] = k; 
}

int deQueue(Queue* obj) {
    int a = obj->data[obj->front];
    if(obj->rear == obj->front){
        obj->rear=obj->front=-1;
        return a;
    }
    obj->front = (obj->front+1)%obj->len;
    return a;
}

int isEmpty(Queue *obj){
    return obj->front == -1;
}
int QSize(Queue *obj){
    if(isEmpty(obj)){
        return 0;
    }
   return (obj->rear-obj->front+1)%obj->len;
}

typedef struct {
    Queue *queue;
} MyStack;

MyStack* myStackCreate() {
    MyStack *obj = (MyStack*)malloc(sizeof(MyStack));
    obj->queue = initQueue(LEN);
    return obj;
}

void myStackPush(MyStack* obj, int x) {
    int n = QSize(obj->queue);
    enQueue(obj->queue,x);
    while(n-->0){
        int temp = deQueue(obj->queue);
        enQueue(obj->queue,temp);
    }
}

int myStackPop(MyStack* obj) {
    return deQueue(obj->queue);
}

int myStackTop(MyStack* obj) {
    return obj->queue->data[obj->queue->front];
}

bool myStackEmpty(MyStack* obj) {
    return isEmpty(obj->queue);
}

void myStackFree(MyStack* obj) {
    free(obj->queue->data);
    free(obj->queue);
    free(obj);
}

/**
 * Your MyStack struct will be instantiated and called as such:
 * MyStack* obj = myStackCreate();
 * myStackPush(obj, x);
 
 * int param_2 = myStackPop(obj);
 
 * int param_3 = myStackTop(obj);
 
 * bool param_4 = myStackEmpty(obj);
 
 * myStackFree(obj);
*/
```

## [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

```c
typedef struct {
    int stack[10000];
    int top;
}Stack;

Stack *initStack(){
    Stack *s = (Stack*)malloc(sizeof(Stack));
    s->top = 0;
    return s;
}

void push (Stack *obj,int x) {
    obj->stack[obj->top++] = x;
}

int pop(Stack *obj) {
    obj -> top--;
    return obj->stack[obj->top];
}

int getTop(Stack *obj) {
    return obj->stack[obj->top - 1];
}

int isEmpty(Stack *obj) {
    return obj->top == 0;
}
bool isValid(char * s){
    int sLen = strlen(s);
    Stack *s1 = initStack();
    for(int i = 0; i < sLen;i++){
        char temp = s[i];
        if(temp == '(' || temp == '{' || temp == '['){
            push(s1,temp);
        }else if(temp == ')'&&!isEmpty(s1)){
            if(getTop(s1) != '(') return 0;
            pop(s1);
        }else if(temp == '}'&&!isEmpty(s1)){
            if(getTop(s1) != '{') return 0;
            pop(s1);
        }else if(temp == ']'&&!isEmpty(s1)){
            if(getTop(s1) != '[') return 0;
            pop(s1);
        }else{
            push(s1,temp);
        }
    }
    return isEmpty(s1);
}
```

```c
char pairs(char temp){
    if(temp == '}') return '{';
    if(temp == ')') return '(';
    if(temp == ']') return '[';
    return 0;
}

bool isValid(char * s){
    int n = strlen(s);
    if(n % 2 == 1) return false;
    int stk[n + 1],top = 0;
    for(int i = 0;i < n;i++){
        char ch = pairs(s[i]);//获得相应的括号
        if(ch){//当为右括号的时候
            if(top == 0 || stk[top - 1] != ch) {
                return false;//匹配不上
            }
            top--;//匹配的上就pop
        }else{
            stk[top++] = s[i];//push
        }
    }
    return top == 0;
}
```

## [1047. 删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

```c
typedef struct {
    char *stack;
    int top;
}Stack;

Stack *initStack(int k){
    Stack *s = (Stack*)malloc(sizeof(Stack));
    s->stack= (char*)malloc(sizeof(char)*k);
    s->top = 0;
    return s;
}

void push (Stack *obj,int x) {
    obj->stack[obj->top++] = x;
}

char pop(Stack *obj) {
    if(obj->top != 0){
         obj -> top--;
    }
    return obj->stack[obj->top];
}

char getTop(Stack *obj) {
    return obj->stack[obj->top - 1];
}

int isEmpty(Stack *obj) {
    return obj->top == 0;
}
char * removeDuplicates(char * s){
    int sLen = strlen(s);
    Stack *stk = initStack(sLen); 
    int newLen = 0;
    for(int i = 0;i < sLen;i++){
        if(isEmpty(stk)){
            push(stk,s[i]);
            newLen++;
        }else if(getTop(stk) == s[i]){
            pop(stk);
            newLen--;
        }else{
            push(stk,s[i]);
            newLen++;
        }
    }
    stk->stack[newLen] = '\0';
    return stk->stack;
}
```

```c


char * removeDuplicates(char * s){
    int sLen = strlen(s);
    //开辟栈空间。栈空间长度应为字符串长度+1
    char *stack = (char*)malloc(sizeof(char) * sLen + 1);
    int stkTop = 0;
    int index = 0;
    //遍历整个字符串
    while (index < sLen) {
        char letter = s[index++];
        if(stkTop > 0 && letter == stack[stkTop - 1]){
            stkTop--;//出栈
        }else{
            stack[stkTop++] = letter;//否则将字母入栈
        }
    }
    stack[stkTop] = '\0';
    return stack;
}
```

## [150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

![image-20220827202215281](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/image-20220827202215281.png)

### 栈

```c
bool isNumber(char* s){
    return (s[0]=='-'&&(s[1] >= '0' && s[1] <= '9'))||(s[0] >= '0' && s[0] <= '9');
    // return strlen(s) >1 || (s[0] >= '0' && s[0] <= '9'); 直接判断字符长度大于1 则是数字
}
int evalRPN(char ** tokens, int tokensSize){
    int len = tokensSize;
    int stk[len],top = 0;
    for(int i = 0;i < len;i++){
        char *token = tokens[i];
        if(isNumber(token)){
            int tlen = strlen(token);
            int num = 0;
            int n = 1;
            if(token[0] == '-'){
                for(int j = tlen - 1;j >=1;j--){
                    num -= n*(token[j]-'0');
                    n = n*10; 
                }
            }else{
                for(int j = tlen - 1;j >=0;j--){//错误原因使用的：j++
                    num += n*(token[j] -'0');
                    n = n*10; 
                }
            }
            stk[top++] = num;//是数字就进栈
            // stk[top++] = atoi(token);把参数 str 所指向的字符串转换为一个整数(类型为 int 型)
        }else if(top >=2){
            int lat = stk[--top];
            int fir = stk[--top];
            
            int res;
            switch(token[0]){
                case '+': res = fir + lat;break;
                case '-': res = fir - lat;break;
                case '*': res = fir * lat;break;
                case '/': res = fir / lat;break;
            }
            stk[top++] = res;
        }
    }
    return stk[0];
}
```

### 数组模拟栈

==数组空间计算更加精确，利用空间更小==

![image-20220827220030142](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/image-20220827220030142.png)

```c


int evalRPN(char ** tokens, int tokensSize){
    int n = tokensSize;
    int stk[(n+1)/2];
    memset(stk,0,sizeof(stk));
    int index = -1;
    for(int i = 0;i < n;i++){
        char * token = tokens[i];
        if(strlen(token) > 1 || isdigit(token[0])){//isdigit检查其参数是否为十进制数字字符。
            index++;
            stk[index] = atoi(token);
        }else{
            switch(token[0]){
                case'+':
                    index--;
                    stk[index] += stk[index + 1];
                    break;
                case'-':
                    index--;
                    stk[index] -= stk[index + 1];
                    break;
                     case'*':
                    index--;
                    stk[index] *= stk[index + 1];
                    break;
                     case'/':
                    index--;
                    stk[index] /= stk[index + 1];
                    break;
            }
        }
    }
    return stk[index];
}
```

##  [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)（单调队列

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */

typedef struct {
    int *data;
    int rear;
    int head;
    int size;
} Queue;
Queue *initQueue(int k) {
    Queue *obj = (Queue *)malloc(sizeof(Queue));
    obj -> data = (int *)malloc(sizeof(int) *k);
    obj -> head = -1;
    obj -> rear = -1;
    obj -> size = k;
    return obj;
}
void enQueue(Queue *obj, int e) {
    if (obj -> head == -1) {
        obj -> head =0;
    }
    obj -> rear = (obj ->rear + 1)% obj -> size;
    obj -> data[obj -> rear] = e;
}//插入队列
int deQueue(Queue *obj) {
    int a = obj -> data[obj -> head];
    if (obj -> head == obj -> rear) {
        obj -> rear = -1;
        obj -> head = -1;
        return a; 
    }
    obj -> head = (obj -> head + 1) % obj->size;
    return a;
}
int de_back(Queue *obj){
    int a = obj -> data[obj -> rear];
    if (obj -> head == obj -> rear) {
        obj -> rear = -1;
        obj -> head = -1;
        return a; 
    }
    obj -> rear = (obj -> rear - 1) % obj->size;
    return a;
}
int isEmpty(Queue *obj) {
    return obj -> head == -1;
}
//***********************队列基础操作**********************
//使用单调队列
//其实队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队里里的元素数值是由大到小的。
int front(Queue *obj){//此处查询当前队列里的最大值
    return obj->data[obj->head];
}
int back(Queue *obj){//此处查询当前队列里的最小值
    return obj->data[obj->rear];
}
//每次弹出的时候，比较当前要弹出的数值是否等于出口队列元素，相等则弹出。
//同时pop时判断队列是否为空
void pop(Queue *obj,int value){
    if(!isEmpty(obj) && value == front(obj)){
        deQueue(obj);
    }
}
//如果push的数值大于入口的值，就将队列后端的数值弹出，知道小于等于出口
//这样就保持了队列里的数值是单调从大到小的
void push(Queue *obj,int value){
    while(!isEmpty(obj) && value > back(obj)){
        de_back(obj);
    }
    enQueue(obj,value);
}

int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize){
    Queue *queue = initQueue(1000000);
    int *res = (int *)malloc(sizeof(int) * 1000000);
    int index = 0;
    for(int i = 0; i < k;i++){
        push(queue,nums[i]);
    }//先将前k个元素放进队列
    res[index++] = front(queue);
    for(int i = k;i < numsSize;i++){
        pop(queue,nums[i-k]);//滑动窗口移除最前面元素
        push(queue,nums[i]);//滑动窗口前加入最后面的元素
        res[index++] = front(queue);
    }
    *returnSize = index;
    return res;
}
```

## [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)（优先级队列

==**使用小根堆+哈希表**==

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
struct hash_table {
    int key;
    int val;
    UT_hash_handle hh;
};
typedef struct hash_table* hash_ptr;
typedef struct pair{
    int first;
    int second;
}pair;//pair是将2个数据组合成一组数据，当需要这样的需求时就可以使用pair，如stl中的map就是将key和value放在一起来保存。另一个应用是，当一个函数需要返回2个数据的时候，可以选择pair。
void swap(pair *a,pair *b){
    pair temp = *a;
    *a = *b;
    *b = temp;
}
inline bool cmp (const pair*a,const pair* b){
    //在编写程序过程中，对于短小而且需要频繁调用的函数，可以将其声明为inline()函数。在调用该函数的过程中编译器会自动选择是否展开该函数。
    return a->second < b->second;
}
pair top(pair * heap){
    return heap[1];//从数组索引为1处开始储存
}
//构造小根堆
void push(pair* heap,int * heapSize,hash_ptr x){
    heap[++(*heapSize)].first = x->key;
    heap[(*heapSize)].second = x->val;
    int childs = (*heapSize), parent = 0;//子代和父代的索引
    while(childs > 1){
        parent = childs >> 1;//childs除二得到父代
        if(cmp(&heap[parent],&heap[childs])){
            //如果父代比子代小则不需要交换 直接结束
            return;
        }
        swap(&heap[childs],&heap[parent]);
        childs = parent;//继续heapify 沿着父代继续
    }
}
void pop(pair* heap,int * heapSize){
    heap[1] = heap[(*heapSize)--];//将堆顶元素弹出并且用最后一个元素代替
    int parent = 1,childs = 0;
    while((parent << 1) <= (*heapSize)){//保证选取的不是叶子结点
        childs = parent << 1;
        if(childs < (*heapSize) && cmp(&heap[childs+1] , &heap[childs])){
            ++childs;//若右孩子小于左孩子，则选用右孩子与父节点交换
        }
        if(cmp(&heap[parent],&heap[childs])){
            return;//如果父代比子代小则不需要交换 直接结束
        }
        swap(&heap[parent],&heap[childs]);
        parent = childs;
    }
}
int* topKFrequent(int* nums, int numsSize, int k, int* returnSize){
    hash_ptr head = NULL;
    hash_ptr p = NULL, tmp = NULL;
    for(int i = 0;i < numsSize;i++){
        HASH_FIND_INT(head,&nums[i],p);//用p来接受
        if(p==NULL){
            //第一次出现
            p = malloc(sizeof(struct hash_table));
            p->key = nums[i];
            p->val = 1;
            HASH_ADD_INT(head,key,p);
        }else{
            ++p->val;//出现多次
        }
    }
    pair *heap = malloc(sizeof(pair) *(k+1));
    int heapSize = 0;
    for(p = head;p != NULL;p = p->hh.next){// 还有一个hh.prev指针，可用于从任何已知项开始向后迭代哈希。
//由于hh.prev和hh.next字段的缘故，可以在哈希中向前和向后迭代。可以通过重复跟随这些指针来访问哈希中的所有项目，因此哈希也是双链表。
        if(heapSize == k){
            pair temp = top(heap);
            if(temp.second < p->val){
                pop(heap,&heapSize);
                push(heap,&heapSize,p);//堆满时，如果堆顶元素小于当前插入元素，则弹出堆顶
            }
        }else{
            push(heap,&heapSize,p);
        }
    }
    *returnSize = k;
    int *ret = malloc(sizeof(int) * k);
    for(int i = k-1;i >= 0;i--){
        pair tmp = top(heap);
        pop(heap,&heapSize);
        ret[i] = tmp.first;//从小到大将数据保存
    }
    return ret;
}
```

## [71. 简化路径](https://leetcode.cn/problems/simplify-path/)

1. 自己写的纯靠拼凑的方法

```c
typedef struct {
    char *data;
    int top;
}Stack;
bool isLetter(char x){
    return (x >= '0' && x<='9') || (x >= 'a' && x<='z');
}
Stack *initStack(int k){
    Stack *s = malloc(sizeof(Stack));
    s->data = malloc(sizeof(char) * k);
    s->top = 0;
    return s;
}
bool isEmpty(Stack *s){
    return s->top == 0;
}
void push(Stack *s,char x){
    s->data[s->top++] = x;
}
char pop(Stack *s){
    char ret = s->data[--s->top];
    return ret;
}
char getTop(Stack *s){
    return s->data[s->top - 1];
}
char * simplifyPath(char * path){
    Stack *stack = initStack(3000);
    int len = strlen(path);
    int index;
    int i;
    for( i= 0;i < len;i++){
        char tmp = path[i];
        if(i == 0){
            //第一次直接push/
            push(stack,path[i]);
        }else{
            if(i < len -2 && isLetter(path[i]) && path[i+1] == '/'){//是字母数字且下一个是斜杠就跳过斜杠push
                push(stack,path[i++]);
                push(stack,'/');
            }else if(i == len -2 && isLetter(path[i]) && path[i+1] == '/'){
                push(stack,path[i++]);
            }else if(i <= len -2 && isLetter(path[i]) && isLetter(path[i+1])){
                 push(stack,path[i]);
            }else if(i <= len -2 && !isLetter(tmp)){ 
                char topL = getTop(stack);
                switch(path[i]){
                    case '/':{
                        if(topL == '/'){
                            //出现多个斜杠直接跳过
                        }
                        break;
                    }
                    case '.':{
                        if(path[i+1]=='/'){
                            i++;
                        }else if(path[i+1] == '.' &&path[i+2] !='.' && stack->top!=1){
                            pop(stack);
                            while(getTop(stack) != '/' && !isEmpty(stack)){
                                pop(stack);
                            }
                            i+=2;
                        }else if(path[i+1] == '.' &&path[i+2] !='.' && stack->top ==1 && getTop(stack) =='/'){
                           
                            i+=2;
                        }else if(path[i+1]=='.'&&path[i+2]=='.'){
                            push(stack,'.');
                            push(stack,'.');
                            push(stack,'.');
                            i+=3;
                        }
                    }
                }
            
            }
        }
    }
    if(i == len - 1 || i == len ||i==len+1 ){
        if(stack->top > 1 &&stack->data[stack->top-1] == '/')
        pop(stack);
    }
     //放弃push最后一个斜杠
    char* ret = malloc(sizeof(char)*(stack->top+1));
    for(int i = 0;i < stack->top;i++){
        ret[i] = stack->data[i];
    }
    ret[stack->top] = '\0';
    return ret;
}
```

```c
/*
首先将给定的字符串path根据 / 分割成一个由若干字符串组成的列表，记为names
names中包含的字符串只能分为以下几种：
1. 空字符串：例如当出现多个连续的/，就会分割出空字符串
2. 一个点 . ：对于上述两种情况我们实际上无须处理 空字符串没有意义 并且.表示当前目录本身无需切换目录
3. 两个点 .. ：
4. 只包含英文字母、数字或_的目录名:
    对于两个点或者目录名，我们则可以用一个栈来维护路径中的每一个目录名。
    遇到两个点，需要将目录切换到上一级，因此只有栈不为空，我们就弹出栈顶目录
    遇到目录名时，就把它放进栈
*******************************
可以使用strtok库函数 根据 / 分割path成若干字符串
strtok函数的基本使用方法:
输入一个字符串数组，然后就可以将其按照一定的分隔符(解法中为"/")将一个长的字符串分割成一个个短的字符串（‘/’替换成’\0’，也就是替换成了字符串结束标志字符）;
这里需要注意的是，在对一个长字符串分割的时候，第一次调用时，strtok函数的第一个参数传入要分割的字符串，而第二次以及后面再次调用该函数的时候，strtok函数的第一个参数应该传入NULL;
这是因为在strtok第一个参数为NULL的时候，该函数默认使用上一次未分割完的字符串的未分割的起始位置作为本次分割的起始位置，直到分割结束为止。
*******************************
可以使用strcmp库函数 对names 中包含的字符串进行分析判断
strcmp()函数返回一个int或整数类型。 我们可以得到以下三种返回值类型。
如果两个字符串相同，相等或相同，则返回“ 0”;
“负整数”，如果第一个不匹配字符的ASCII值小于第二个字符;
如果第一个不匹配字符的ASCII值大于第二个，则为“正整数”
*/

char * simplifyPath(char * path){
    char *stack[100];//char*类型的数组，每个数组存储一个字符串
    int size = 0;
    for(char *s = strtok(path,"/") ;s;s = strtok(NULL,"/")){
        if(strcmp(s,".") == 0){//第二种情况不处理
        }else if(strcmp(s,"..") == 0){//第三种情况回退并保证始终在根目录
            size = fmax(0,size - 1);//这就保证在空栈的时候也能保证在根目录
        }else{//第四种情况
            stack[size++] = s;
        }//第一种情况默认不处理
    }
    if (size == 0){
        return "/";
    }
    /*calloc与malloc的区别
1.参数的使用方式不同
malloc(单位：字a节)：malloc(10 * sizeof(int));或malloc(40)
calloc:calloc(10 , sizeof(int))
2.malloc的使用效率较高，因为calloc在返回在堆区申请的那块动态内存的起始地址之前，会将每个字节都初始化为0
    */
//malloc 和 calloc 之间的不同点是，malloc 不会设置内存为零，而 calloc 会设置分配的内存为零。
    char *res = calloc(1000, sizeof(char));
    for(int i = 0;i < size;i++){
        strcat(res,"/");
        strcat(res,stack[i]);
    }
    return res;
}
```

# ==二叉树==

## [144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

### 递归

````c
void preOrder(struct TreeNode* root,int *ret,int *returnSize){
    if(root == NULL){
        return NULL;
    }
    ret[(*returnSize)++] = root->val;
    preOrder(root->left,ret,returnSize);
    preOrder(root->right,ret,returnSize);
}
int* preorderTraversal(struct TreeNode* root, int* returnSize){
    int * ret = malloc(sizeof(int) * 100);
    *returnSize = 0;
    preOrder(root,ret,returnSize);
    return ret;
}
````

### 迭代

迭代的两个操作

```c
//迭代
int* preorderTraversal(struct TreeNode* root, int* returnSize){
    int *ret = (int *)malloc(sizeof(int) * 100);
     *returnSize = 0;
    if(root == NULL) return ret;
    //利用栈来模拟递归
    *returnSize = 0;
    struct TreeNode* stack[100];
    struct TreeNode* node = root;
    int stkTop = 0;
    while(stkTop > 0 || node != NULL){
        while(node != NULL){
            ret[(*returnSize)++] = node -> val;
            stack[stkTop++] = node;
            node = node -> left;//中 --> 左
        }
        //node为null表示左边无子树了该往右走
        node = stack[--stkTop];
        node = node -> right;
    }
    return ret;
}
```

![二叉树前序遍历（迭代法）](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/008eGmZEly1gnbmss7603g30eq0d4b2a.gif)

```c
//迭代二 利用栈的弹出顺序
int* preorderTraversal(struct TreeNode* root, int* returnSize){
    int *ret = malloc(sizeof(int) * 100);
    *returnSize = 0;
    if(root == NULL) return ret;
    struct TreeNode* stack[100];
    int stkTop = 0;
    stack[stkTop++] = root;
    while(stkTop > 0) {
        struct TreeNode* node = stack[--stkTop];
        ret[(*returnSize)++] = node -> val;
        if(node -> right){
            stack[stkTop++] = node -> right;
        }
        if(node -> left) {
            stack[stkTop++] = node -> left;
        }
        //先右后左，弹出时就是先左后右符合遍历顺序
    } 
    return ret;
}
```

### [589. N 叉树的前序遍历](https://leetcode.cn/problems/n-ary-tree-preorder-traversal/)

#### 递归

```c
void pre(struct Node*root,int *ret,int *returnSize){
    if(root==NULL) return ;
    ret[(*returnSize)++] = root -> val;
    for(int i = 0;i < root -> numChildren;i++){
        pre(root->children[i],ret,returnSize);
    }
}
int* preorder(struct Node* root, int* returnSize) {
    *returnSize = 0;
    int *ret = (int*)malloc(sizeof(int)*10000);
    pre(root,ret,returnSize);
    return ret;
}
```

#### 迭代

```c
int* preorder(struct Node* root, int* returnSize) {
    *returnSize = 0 ;
    int* ret  = (int *)malloc(sizeof(int)*10000);
    if(root == NULL) return ret;
    struct Node* stack[10000];
    int stk = 0;
    stack[stk++] = root;
    while(stk > 0) {
        struct Node* node =stack[--stk];
        ret[(*returnSize)++] = node -> val;
        for(int i = node->numChildren -1;i >=0;i--){
            if(node->children[i]){
                stack[stk++] = node->children[i];
            }
        } 
    }
    return ret;
}
```



## [145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

### 递归

```c
//后序递归
void postOrder(struct TreeNode *root,int *ret,int *returnSize) {
    if(root == NULL) return  NULL;
    postOrder(root -> left,ret,returnSize);
    postOrder(root -> right,ret,returnSize);
    ret[(*returnSize)++] = root -> val;
}
int* postorderTraversal(struct TreeNode* root, int* returnSize){
    int *ret = (int *)malloc(sizeof(int) * 100);
    *returnSize = 0;
    postOrder(root,ret,returnSize);
    return ret;
}
```

### 迭代

> 再来看后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：
>
> ![前序到后序](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/20200808200338924.png)
>
> **所以后序遍历只需要前序遍历的代码稍作修改就可以了**

``` c
int* postorderTraversal(struct TreeNode* root, int* returnSize){
    int *ret = (int *)malloc(sizeof(int) * 100);
    *returnSize = 0;
    if(root = NULL) return ret;
    struct TreeNode* stack[100];
    struct TreeNode* node = root,*pre = NULL;
    int stkTop = 0;
    while(stkTop > 0 || node != NULL ) {
        while(node -> left != pre){
            stack[stkTop++] = node;
            pre = node;
            node = node -> left;
        }
        ret[(*returnSize)++] = stack[stkTop - 1]->val;
        node = stack[--stkTop];
        if(node -> right != NULL  && node ->right != pre){
            pre = node;
            node = node -> right;
        }
    }
    return ret;
}
```

```c
//因为先序是中左右 后序是左右中 即将先序的左右调换位置变成中右左再将得到的数组反转，得到左右中即后序遍历
int* postorderTraversal(struct TreeNode* root, int* returnSize){
    
    int *ret = malloc(sizeof(int) * 100);
    *returnSize = 0;
    if(root == NULL) return ret;
    struct TreeNode* stack[100];
    int stkTop = 0;
    stack[stkTop++] = root;
    while(stkTop > 0) {
        struct TreeNode* node = stack[--stkTop];
        ret[(*returnSize)++] = node -> val;
        if(node -> left) {
            stack[stkTop++] = node -> left;
        }
        if(node -> right){
            stack[stkTop++] = node -> right;
        }
        //先右后左，弹出时就是先左后右符合遍历顺序
    } 
    int left = 0,right = *returnSize - 1;
    while(left <= right){
        int temp = ret[left];
        ret[left++] = ret[right];
        ret[right--] = temp;
    }
    return ret;
}
```

### [590. N 叉树的后序遍历](https://leetcode.cn/problems/n-ary-tree-postorder-traversal/)

#### 递归

```c
void post(struct Node* root,int *ret,int*returnSize){
    if(root ==NULL) return ;
    for(int i = 0;i < root->numChildren;i++){
        post(root->children[i],ret,returnSize);
    }
    ret[(*returnSize)++] = root->val;
}
int* postorder(struct Node* root, int* returnSize) {
    *returnSize = 0;
    int *ret = (int *)malloc(sizeof(int) * 10000);
    post(root,ret,returnSize);
    return ret;
}
```



## [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

### 递归

```c
//中序递归
void inOrder(struct TreeNode* root,int* ret,int* returnSize){
    if(root == NULL) {
        return NULL;
    }
    inOrder(root -> left,ret,returnSize);
    ret[(*returnSize)++] = root->val;
    inOrder(root -> right,ret,returnSize);
}
int* inorderTraversal(struct TreeNode* root, int* returnSize){
    int*ret = malloc(sizeof(int) * 100);
    *returnSize = 0;
    if(root == NULL ) return ret;
    inOrder(root,ret,returnSize);
    return ret;
}
```

### 迭代

> 分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，**因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。**
>
> 那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了**处理顺序和访问顺序是不一致的。**
>
> 那么**在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素**

![二叉树中序遍历（迭代法）](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/008eGmZEly1gnbmuj244bg30eq0d4kjm.gif)

```c
int* inorderTraversal(struct TreeNode* root, int* returnSize){
    int*ret = malloc(sizeof(int) * 100);
    *returnSize = 0;
    if(root == NULL) {
        return ret;
    }
    struct TreeNode* stack[100];
    struct TreeNode* cur =root;
    int stkTop = 0;
    while(stkTop > 0 || cur != NULL) {
        if(cur != NULL){//用指针来访问结点，访问到最底层
            stack[stkTop++] = cur;
            cur = cur->left;
        }//核心思想就是左边遍历到头全部压栈，弹出是访问根节点，再进入右边
        //不用考虑走重复路线问题，因为当弹出到左边某一结点时，其下所有结点均已被访问
        else{
            cur = stack[stkTop - 1];
            ret[(*returnSize)++] = stack[--stkTop]->val;
            cur = cur -> right;
        }
    }
    return ret;
}
```

## 前中后序遍历迭代法统一格式

**无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况**。

**那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。**

如何标记呢，**就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。** 这种方法也可以叫做标记法。

### 中序迭代

```c
//中序迭代
int* inorderTraversal(struct TreeNode* root, int* returnSize){
    int *ret = malloc(sizeof(int) * 100);
    *returnSize = 0;
    if(root == NULL) return ret;
    struct TreeNode * stack[100];
    int stkTop = 0;
    stack[stkTop++] = root;
    while(stkTop > 0) {
        struct TreeNode* node = stack[stkTop - 1];
        if(node != NULL){
            stkTop--;//将该节点弹出，避免重复加入，再将右中左依次加入，这样弹出时是按左中右
            if(node -> right) stack[stkTop++] = node -> right;
            stack[stkTop++] = node; stack[stkTop++] = NULL;//添加中结点，但是还没有处理，加入空节点做标记
            if(node -> left) stack[stkTop++] = node -> left;
        }else{//相当于没有左右孩子或左孩子已经被访问
            stkTop--;
            node = stack[--stkTop];
            ret[(*returnSize)++] = node -> val;
        }
    }
    return ret;
}
```

### 前序遍历

```c
int* preorderTraversal(struct TreeNode* root, int* returnSize){

    int *ret = malloc(sizeof(int) * 100);
    *returnSize = 0;
    if(root == NULL) return ret;
    struct TreeNode * stack[100];
    int stkTop = 0;
    stack[stkTop++] = root;
    while(stkTop > 0) {
        struct TreeNode* node = stack[stkTop - 1];
        if(node != NULL){
            stkTop--;//将该节点弹出，避免重复加入，再将右左根依次加入，这样弹出时是按根左右     
            if(node -> right) stack[stkTop++] = node -> right;      
            if(node -> left) stack[stkTop++] = node -> left;
            stack[stkTop++] = node; stack[stkTop++] = NULL;//添加中结点，但是还没有处理，加入空节点做标记
        }else{//相当于只要访问过该节点就弹出
            stkTop--;
            node = stack[--stkTop];
            ret[(*returnSize)++] = node -> val;
        }
    }
    return ret;

}
```

### 后序迭代

```c
int* postorderTraversal(struct TreeNode* root, int* returnSize){
    int *ret = malloc(sizeof(int) * 100);
    *returnSize = 0;
    if(root == NULL) return ret;
    struct TreeNode * stack[100];
    int stkTop = 0;
    stack[stkTop++] = root;
    while(stkTop > 0) {
        struct TreeNode* node = stack[stkTop - 1];
        if(node != NULL){
            stkTop--;//将该节点弹出，避免重复加入，再将根右左依次加入，这样弹出时是按左右根
            
              stack[stkTop++] = node; stack[stkTop++] = NULL;//添加中结点，但是还没有处理，加入空节点做标记
            if(node -> right) stack[stkTop++] = node -> right;      
            if(node -> left) stack[stkTop++] = node -> left;
             
        }else{//相当于只要访问过该节点就弹出
            stkTop--;
            node = stack[--stkTop];
            ret[(*returnSize)++] = node -> val;
        }
    }
    return ret;
}
```

### 总结

使用此方法的**好处**在于，能采用统一的结构进行迭代，只要在已经访问过的结点前加个null，然后利用栈先进后出的原理，调整入栈顺序，比如：**前序遍历**是**根左右**，我们就按照**右左根**的顺序入栈即可。

三个代码==不同部分==如下

```c
if(node != NULL){
            stkTop--;//将该节点弹出，避免重复加入，再将根右左依次加入，这样弹出时是按左右根
            
              stack[stkTop++] = node; stack[stkTop++] = NULL;//添加中结点，但是还没有处理，加入空节点做标记  > 根
            if(node -> right) stack[stkTop++] = node -> right;  > 右 
            if(node -> left) stack[stkTop++] = node -> left; > 左
             
        }
逆序后得左右根为后序遍历
```

## [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

**思路**：利用辅助队列来实现，队列先进先出，符合一层一层遍历的逻辑

![102二叉树的层序遍历](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/008eGmZEly1gnad5itmk8g30iw0cqe83.gif)

```c
//使用结构体定义队列
//错误原因在于isEmpty函数return错误导致true false相反，循环未执行
typedef struct {
    struct TreeNode* data[2001];
    int front;
    int rear;
    int size;
}Queue;
Queue* initQueue(int k) {
    Queue* queue = (Queue*)malloc(sizeof(Queue));
    queue -> rear = -1;
    queue -> front = -1;
    queue -> size = k;
    return queue;
}
int Qsize(Queue* queue){
    if(queue->rear == -1) return 0;
    return queue->rear - queue->front;
}
struct TreeNode* pop(Queue *queue) {
    if(queue->rear == -1){
        return NULL;
    }
    struct TreeNode* ret = queue->data[queue->front];
    queue->front = (queue->front + 1) % queue-> size;
    return ret;
}
void push(Queue *queue,struct TreeNode* k) {
    if(queue->rear == -1){
        queue->rear=1;
        queue->front=0;
        queue->data[0] = k;
        return ;
    }
    queue->data[queue->rear] = k;
    queue->rear = (queue->rear+1)%queue->size;
     
}
bool isEmpty(Queue *queue){
    return queue->front == queue->rear;
}
int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes){
    *returnSize = 0;
      if(root == NULL)  return NULL;
    Queue* queue = initQueue(2001);
    int **ret = (int**)malloc(sizeof(int*)*2001);
    
    *returnColumnSizes = (int*)malloc(sizeof(int)*2001);
  
    push(queue,root);
    while(!isEmpty(queue)) {
        int size = Qsize(queue);//用当前队列的存入元素的大小
        ret[(*returnSize)] = (int *)malloc(sizeof(int)*size);
        for(int i = 0;i < size;i++) {
            struct TreeNode* node = pop(queue);//弹出元素
            ret[*returnSize][i] = node -> val;
            if(node -> left) push(queue,node->left);
            if(node -> right) push(queue,node->right);
            
        }
        
        (*returnColumnSizes)[(*returnSize)++] = size;
    }
    return ret;
}
```

```c
//相同思路，未使用结构化的队列
int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes){
    *returnSize = 0;
    if(root == NULL) return NULL;
    int** ret = (int**)malloc(sizeof(int*) * 2001);
    *returnColumnSizes = (int*)malloc(sizeof(int) * 2001);
    struct TreeNode* queueDat[2001];
    int front = 0;
    int rear = 0;
    queueDat[rear++] = root;
    while(front != rear){
        int size = rear - front;
        ret[*returnSize] = (int *)malloc(sizeof(int) * size);
        for(int i = 0;i < size;i++){
            struct TreeNode* node = queueDat[front++];
            ret[*returnSize][i] = node -> val;
            if(node -> left) queueDat[rear++] = node -> left;
            if(node -> right) queueDat[rear++] = node -> right;
        }
        (*returnColumnSizes)[*returnSize] = size;
        (*returnSize)++;
    }
    return ret;
}
```

## [107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

> 利用Ⅰ将得到的数组逆序

```c
int** levelOrderBottom(struct TreeNode* root, int* returnSize, int** returnColumnSizes){

    *returnSize = 0;
    if(root == NULL) return NULL;
    int** ret = (int**)malloc(sizeof(int*) * 2001);
    *returnColumnSizes = (int*)malloc(sizeof(int) * 2001);
    struct TreeNode* queueDat[2001];
    int front = 0;
    int rear = 0;
    queueDat[rear++] = root;
    while(front != rear){
        int size = rear - front;
        ret[*returnSize] = (int *)malloc(sizeof(int) * size);
        for(int i = 0;i < size;i++){
            struct TreeNode* node = queueDat[front++];
            ret[*returnSize][i] = node -> val;
            if(node -> left) queueDat[rear++] = node -> left;
            if(node -> right) queueDat[rear++] = node -> right;
        }
        (*returnColumnSizes)[*returnSize] = size;
        (*returnSize)++;
    }
    for(int i = 0;i < *returnSize/2;i++){
        int*temp = ret[i];
        int temp1 = (*returnColumnSizes)[i];
        ret[i] = ret[*returnSize -1 - i];
        ret[*returnSize - 1 - i] = temp;
        (*returnColumnSizes)[i] = (*returnColumnSizes)[*returnSize - i - 1];
        (*returnColumnSizes)[*returnSize - i - 1] = temp1;
    }
    return ret;

}
```

## [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

![image-20220831114635671](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/image-20220831114635671.png)

```c
//错误思路：只考虑了最右边的子树，实际会出现右边子树层数小于左边导致最终答案包含左边
int* rightSideView(struct TreeNode* root, int* returnSize){
    *returnSize = 0;
    int*ret = (int*)malloc(sizeof(int) * 201);
    if(root == NULL) return NULL;
    struct TreeNode* node = root;
    ret[(*returnSize)++] = root->val;
    while(node -> left || node -> right){
        if(node -> right) {
            node = node -> right;
            ret[(*returnSize)++] = node -> val;
        }else if(node ->left){
            node = node -> left;
            ret[(*returnSize)++] = node -> val;
        }

    }
    return ret;
}
```

### 未优化

```c
//正确思路 
int* rightSideView(struct TreeNode* root, int* returnSize){
//相同思路，未使用结构化的队列
//利用层次遍历，提取层次每一个层次的最后一个元素
    int**returnColumnSizes = (int**)malloc(sizeof(int*)*2001);
    *returnSize = 0;
    if(root == NULL) return NULL;
    int** ret = (int**)malloc(sizeof(int*) * 2001);
    *returnColumnSizes = (int*)malloc(sizeof(int) * 2001);
    struct TreeNode* queueDat[2001];
    int front = 0;
    int rear = 0;
    queueDat[rear++] = root;
    while(front != rear){
        int size = rear - front;
        ret[*returnSize] = (int *)malloc(sizeof(int) * size);
        for(int i = 0;i < size;i++){
            struct TreeNode* node = queueDat[front++];
            ret[*returnSize][i] = node -> val;
            if(node -> left) queueDat[rear++] = node -> left;
            if(node -> right) queueDat[rear++] = node -> right;
        }
        (*returnColumnSizes)[*returnSize] = size;
        (*returnSize)++;
    }
    int* result = (int *)malloc(sizeof(int) * (*returnSize));
    for(int i = 0;i < *returnSize;i++){
        result[i] = ret[i][(*returnColumnSizes)[i] - 1];
    }
    return result;
}
```

### 优化后

```c
int* rightSideView(struct TreeNode* root, int* returnSize){
//相同思路，未使用结构化的队列
//利用层次遍历，提取层次每一个层次的最后一个元素
    *returnSize = 0;
    if(root == NULL) return NULL;
    struct TreeNode* queueDat[201];
    int front = 0;
    int rear = 0;
    int* result = (int *)malloc(sizeof(int) *201);
    queueDat[rear++] = root;
    while(front != rear){
        int size = rear - front;
        for(int i = 0;i < size;i++){
            struct TreeNode* node = queueDat[front++];
            if(i == (size -1)) result[(*returnSize)++] = node -> val;
            if(node -> left) queueDat[rear++] = node -> left;
            if(node -> right) queueDat[rear++] = node -> right;
        }
       
    }
    return result;
}
```

## [637. 二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

> 在最开始的时候，double ret[10000]没加static 
>
> 报错：load of null pointer of type 'double'
>
> 函数需要返回int*类的数组指针，而我们在实际操作中返回了数组名。虽然在大部分情况下二者可以通用，但是其作用域不同。当我们的函数返回在函数内创建的数组的数组名时，由于退出函数时变量已经销毁了，所以我们其实“什么也没返回”。
>
> 在这种思路下，给出两种解决方案：
>
> 声明数组时增加static。static将作用域延长到程序结束。
> 不声明数组，而是声明指针，并用malloc分配内存。

```c
double* averageOfLevels(struct TreeNode* root, int* returnSize){
    *returnSize = 0;
    if(root == NULL) return NULL;
    struct TreeNode *queue[10000];
    static double ret[10000];
    int front = 0;
    int rear = 0;
    queue[rear++] = root;
    while(rear !=  front) {
        int size = rear - front;
        double sum = 0;
        for(int i = 0;i < size;i++){
            struct TreeNode* node = queue[front++];
            sum += node->val;
            if(node -> left) queue[rear++] = node -> left;
            if(node -> right) queue[rear++] = node -> right;
        }
        ret[(*returnSize)++] = sum / size;
    }
    return ret;
}
```

## [429. N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

```c
int** levelOrder(struct Node* root, int* returnSize, int** returnColumnSizes) {
     *returnSize = 0;
     *returnColumnSizes = (int*)malloc(sizeof(int)*10000);
    if(root == NULL) return NULL;
    struct Node* queueDat[10000];
    int front = 0;
    int rear = 0;
    int** result = (int **)malloc(sizeof(int*) *10000);
    queueDat[rear++] = root;
    while(front != rear){
        int size = rear - front;
        result[*returnSize] = (int*)malloc(sizeof(int) * size);
        for(int i = 0;i < size;i++){
            struct Node* node = queueDat[front++];
            result[*returnSize][i] = node -> val;
            for(int j = 0;j < node->numChildren;j++){
                if(node->children[j]) queueDat[rear++] = node->children[j];
            }
        }
        (*returnColumnSizes)[(*returnSize)++] = size;
    }
    return result;
}
```

## [515. 在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

```c
int* largestValues(struct TreeNode* root, int* returnSize){
    *returnSize = 0;
    if(root == NULL) return NULL;
    struct TreeNode* queueDat[10000];
    int front = 0;
    int rear = 0;
    int* result = (int *)malloc(sizeof(int) *10000);
    queueDat[rear++] = root;
    while(front != rear){
        int size = rear - front;
        int max = queueDat[front] -> val;
        for(int i = 0;i < size;i++){
            struct TreeNode* node = queueDat[front++];
            max = max > node -> val ? max : node -> val;
            if(node -> left) queueDat[rear++] = node -> left;
            if(node -> right) queueDat[rear++] = node -> right;
        }
        result[(*returnSize)++] = max;
       
    }
    return result;
}
```

## [116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)(完全二叉树)

```c
struct Node* connect(struct Node* root) {
    if(root == NULL) return NULL;
    struct Node* queueDat[10000];
    int front = 0;
    int rear = 0;
    queueDat[rear++] = root;
    while(front != rear){
        int size = rear - front;
        for(int i = 0;i < size;i++){
            struct Node* node = queueDat[front++];
            if(i != (size -1) && size > 1) node -> next = queueDat[front];
            if(size - 1 == i) node -> next = NULL; 
            if(node -> left) queueDat[rear++] = node -> left;
            if(node -> right) queueDat[rear++] = node -> right;
        }
    }
    return root;
}
```

## [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)(二叉树)

### 方法一同116代码一样，利用队列先层次遍历然后连接

```c
struct Node* connect(struct Node* root) {
    if(root == NULL) return NULL;
    struct Node* queueDat[10000];
    int front = 0;
    int rear = 0;
    queueDat[rear++] = root;
    while(front != rear){
        int size = rear - front;
        for(int i = 0;i < size;i++){
            struct Node* node = queueDat[front++];
            if(i != (size -1) && size > 1) node -> next = queueDat[front];
            if(size - 1 == i) node -> next = NULL; 
            if(node -> left) queueDat[rear++] = node -> left;
            if(node -> right) queueDat[rear++] = node -> right;
        }
    }
    return root;
}
```

### 方法二

![image.png](https://trae1oung.oss-cn-hangzhou.aliyuncs.com/md/1601259285-fJOatB-image.png)

```c
/*
runtime error: member access within misaligned address 0xbebebebebebebebe for type 'struct Node', which requires 8 byte alignment [solution.c]
0xbebebebebebebebe: note: pointer points here
原因：
我们在访问某个变量时，因为这个变量中含有未赋值的指针。定义但是不赋值的指针叫做野指针。野指针指向不明，对程序有不可知的后果，引用了更是出大问题，所以，c语言严格反对野指针。
*/
struct Node* connect(struct Node* root) {
    if(root == NULL) return root;
    struct Node* cur = root;
    while(cur != NULL) {
        //遍历当前层的时候，为了方便操作在下一层前面添加一个哑结点
        //(注意)这里是访问当前层的结点， 然后把下一层串起来
        struct Node *dummy = (struct Node*)malloc(sizeof(struct Node));//dummy是个头结点
        dummy->right = dummy->left=dummy->next = NULL;//此处易犯错
        struct Node* pre = dummy;//pre表示访问下一层结点的前一个结点，在循环中执行一次pre->next = cur ->?就会记录下一层的起始节点
        //然后开始遍历当前层的链表
        while(cur != NULL) {
            if(cur->left ){
                //当前左子节点不为空，就让pre的指向它
                pre->next = cur->left;
                pre = pre->next;//更新pre
            }
            if(cur->right){
                pre->next = cur->right;
                pre = pre->next;
            }
            cur =cur -> next;//继续访问这一行的下一个节点
        }
        //把下一层串联成一个链表后，让他赋值给cur
        //后序继续循环直到cur为空
        cur = dummy->next;
    }
    return root;
}
```

## [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

### 层次遍历

```c

int maxDepth(struct TreeNode* root){
    if(root == NULL) return 0;
    int depth = 0;
    struct TreeNode* queueDat[10000];
    int front = 0;
    int rear = 0;
    queueDat[rear++] = root;
    while(front != rear){
        int size = rear - front;
        int max = queueDat[front] -> val;
        for(int i = 0;i < size;i++){
            struct TreeNode* node = queueDat[front++];
            if(node -> left) queueDat[rear++] = node -> left;
            if(node -> right) queueDat[rear++] = node -> right;
        }
        depth++;
    }
    return  depth;
}
```

### 递归

```c
int maxDepth(struct TreeNode* root){
	if(root == NULL) return 0;
	return fmax(maxDepth(root->left),maxDepth(root->right)) +1;
}
```

## [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

### 前序递归

```c

struct TreeNode* invertTree(struct TreeNode* root){
    //先序遍历-自顶向下交换
    if(root == NULL) return NULL;
    struct TreeNode* temp = root->left;
    root->left = root->right;
    root->right = temp;
    invertTree(root->left);
    invertTree(root->right);
    return root;
}
```

```c
struct TreeNode* invertTree(struct TreeNode* root){
    if(root == NULL) return NULL;
    //保存右子树
    struct TreeNode *right = root->right;
    root->right = invertTree(root->left);//右子树保存当前左子树交换后的
    root->left =invertTree(right);
    return root;
}
```



### 前序迭代

```c
struct TreeNode* invertTree(struct TreeNode* root){
    if(root == NULL) return NULL;
    struct TreeNode* stack[100];
    int stkTop = 0;
    stack[stkTop++] = root;
    while(stkTop > 0){
        struct TreeNode* node = stack[--stkTop];
        struct TreeNode* temp = node -> left;
        node -> left = node -> right;
        node -> right = temp;
        if(node -> right) stack[stkTop++] = node->right;//右
        if(node -> left) stack[stkTop++] = node -> left;//左
    }
    return root;
}
```

### 中序遍历

```c
//利用中序遍历
struct TreeNode* invertTree(struct TreeNode* root){
    if(root == NULL) return NULL;
    //保存右子树
    struct TreeNode* right = root -> right;
    invertTree(root->left);
    //交换左右子树
    struct TreeNode* temp = root -> left;
    root->right = root -> left;
    root->left = right;
    //交换左右子树后，右子树变成了root->left还需交换一次
    invertTree(root->left);
    return root;
}
```

### 后序遍历

```c
//利用后序遍历
struct TreeNode* invertTree(struct TreeNode* root){
    if(root == NULL) return NULL;
    invertTree(root -> left);
    invertTree(root -> right);
    //将左右子树均交换
    struct TreeNode* temp = root -> left;
    root -> left = root -> right;
    root -> right = temp;
    return root;
}
```

### 统一迭代

```c
struct TreeNode* invertTree(struct TreeNode* root){
    if(root == NULL) return root;
    struct TreeNode* stack[150];
    int stkTop = 0;
    stack[stkTop++] = root;
    while(stkTop > 0){
        struct TreeNode*node = stack[stkTop - 1];
        if(node) {
            stkTop--;
            if(node->left) stack[stkTop++] = node->left;
            if(node->right) stack[stkTop++] = node->right;
            stack[stkTop++] = node;stack[stkTop++] = NULL;//交换这三行顺序可以实现前中后序迭代
        }else{
            stkTop--;
            node = stack[--stkTop];
            struct TreeNode* temp = node -> left;
            node -> left = node -> right;
            node -> right = temp;
        }
    }
    return root;
}
```

### 层次遍历

```c
//层次遍历
struct TreeNode* invertTree(struct TreeNode* root){
    if(root == NULL) return NULL;
    struct TreeNode* queue[100];
    int front = 0;
    int rear = 0;
    queue[rear++] = root;
    while(rear != front){
        int size = rear -front;
        for(int i = 0;i < size ;i++){
            struct TreeNode* node = queue[front++];
            struct TreeNode* temp = node -> left;
            node -> left = node -> right;
            node -> right = temp;
            if(node -> right) queue[rear++] = node -> right;
            if(node -> left) queue[rear++] = node -> left;
        }
    }
    return root;
}
```

## [100. 相同的树](https://leetcode.cn/problems/same-tree/)

### 递归

```c

bool isSameTree(struct TreeNode* p, struct TreeNode* q){
    if(!p && !q) return true;
    if(!p || !q) return false;
    if(p && q && p-> val == q->val){
        return isSameTree(p->left,q->left)&&isSameTree(p->right,q->right);
    }else{
        return false;
    }
}
```

### 前序迭代

```c
bool isSame(struct TreeNode*a,struct TreeNode*b){
    if(!b&&!a)return true;
    if(!b||!a) return false;
    return a->val == b-> val;
}
bool isSameTree(struct TreeNode* p, struct TreeNode* q){
    if(!p&&!q) return true;
    if(!p || !q) return false;
    struct TreeNode* stack1[1000],*stack2[1000];
    int stk1 = 0,stk2 =0;
    stack1[stk1++] = p;
    stack2[stk2++] = q;
    while(stk1>0 && stk2>0){
        struct TreeNode*node1 = stack1[stk1 -1],*node2 = stack2[stk2-1];
        if(isSame(node1,node2)){
            stk1--;
            stk2--;
            if(node1->left||node2->left) {
                stack1[stk1++] = node1 -> left; 
                stack2[stk2++] = node2 ->left; 
            }
            if(node1->right || node2->right) {
                stack1[stk1++] = node1 -> right; 
                stack2[stk2++] = node2 -> right;
            }
        }else{
             return false;
         }
    }
    return stk1 == stk2;
}
```

## [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

###递归

```c
bool Symmetric(struct TreeNode*a,struct TreeNode*b){
    if(!a &&!b) return true;
    if(!a||!b) return false;
    if(a -> val == b->val){
        return Symmetric(a->left,b->right)&&Symmetric(a->right,b->left);
    }
    return false;
}
bool isSymmetric(struct TreeNode* root){
    if(root == NULL) return true;
    return Symmetric(root -> left,root->right);
}
```

### 迭代(队列)

```c
bool isSymmetric(struct TreeNode* root){
    if(root == NULL) return true;
    struct TreeNode*queue[1000];
    int front = 0,rear = 0;
    struct TreeNode*left ,*right;
    queue[rear++] = root->left;queue[rear++] =root->right;
    while(rear!=front){
        left = queue[front++];
        right = queue[front++];
        if(!left && !right) continue;
        if(!left||!right) return false;
        if(left->val!=right->val) return false;      
            //把左节点的左孩子和右节点的右孩子加入队列
            queue[rear++] = left->left;
            queue[rear++] = right->right;
            //把左节点的右孩子和右节点的左孩子加入队列
            queue[rear++] = left->right;
            queue[rear++] = right->left; 
    }
    return rear==front;
}
```

### 迭代(栈)

```c
bool isSymmetric(struct TreeNode* root){
    if(root == NULL) return true;
    struct TreeNode*stack[1000];
    int stk = 0;
    struct TreeNode*left ,*right;
   stack[stk++] = root->left;stack[stk++] =root->right;
    while(stk){
        left = stack[--stk];
        right =stack[--stk];
        if(!left && !right) continue;
        if(!left||!right) return false;
        if(left->val!=right->val) return false;      
            //把左节点的左孩子和右节点的右孩子加入队列
            stack[stk++] = left->left;
            stack[stk++] = right->right;
            //把左节点的右孩子和右节点的左孩子加入队列
            stack[stk++] = left->right;
            stack[stk++] = right->left; 
    }
    return true;
}
```

## [572. 另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/)

> 要判断一个树 t 是不是树 s 的子树，那么可以判断 t 是否和树 s 的任意子树相等。那么就转化成 100. Same Tree。
> 即，这个题的做法就是在 s 的每个子节点上，判断该子节点是否和 t 相等。
>
> 判断两个树是否相等的三个条件是与的关系，即：
>
> 当前两个树的根节点值相等；
> 并且，s 的左子树和 t 的左子树相等；
> 并且，s 的右子树和 t 的右子树相等。
> 而判断 t 是否为 s 的子树的三个条件是或的关系，即：
>
> 当前两棵树相等；
> 或者，t 是 s 的左子树；
> 或者，t 是 s 的右子树。
>

```c
/*
一个树是另一个树的子树，则
1.要么这两个树相等
2.这个树是左树的子树
3.这个树是右树的子树
*/

bool isSame(struct TreeNode*a,struct TreeNode* b){
    if(!a && !b) return true;
    if(!a||!b) return false;
    if(a->val == b->val){
        return isSame(a->left,b->left)&&isSame(a->right,b->right);
    }
    return false;
}

bool isSubtree(struct TreeNode* root, struct TreeNode* subRoot){
   if(!root && !subRoot) return true;
   if(!root || ! subRoot) return false;
   return isSame(root,subRoot) || isSubtree(root->left,subRoot) || isSubtree(root->right,subRoot);
}
```

## [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

### 递归

```c
//后序遍历
int maxDepth(struct TreeNode* root){
    if(root  == NULL) return 0;
    int left = maxDepth(root->left);//左
    int right = maxDepth(root->right);//右
    int depth = fmax(left,right) + 1;//中
    return depth;
}
```

````c
//前序遍历
int ret;
void getMax(struct TreeNode *node,int depth){
    ret = ret > depth ? ret : depth;//中
    if(node->left==NULL&&node->right==NULL) return;//叶子节点递归结束
    if(node->left) getMax(node->left,depth+1);//左
    if(node->right)getMax(node->right,depth+1);//右
    return;
}

int maxDepth(struct TreeNode* root){
    ret = 0;
    if(root == NULL) return ret;
    getMax(root,1);
    return ret;
}
````

### 迭代(层次遍历)

```c
int maxDepth(struct TreeNode* root){
    if(root == NULL) return 0;
    int depth = 0;
    struct TreeNode* queue[10000];
    int front=0,rear=0;   
    queue[rear++] = root;
    while(rear - front >0) {  
        int size = rear - front;
            depth++;
            for(int i = 0;i < size;i++){
                struct TreeNode* node = queue[front++];
                if(node->left)queue[rear++] = node -> left;
                if(node->right)queue[rear++] = node -> right;
     }
    }
    return depth;
}
```

## [559. N 叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/)(同104一样)

### 递归

```c
int maxDepth(struct Node* root) {
    if(root == NULL) return 0;
    int depth = 0;
    for(int i = 0;i < root->numChildren;i++){
        int nowD = maxDepth(root->children[i]);
        depth = depth >  nowD? depth :nowD;
    }//记录所有子树的最大深度
    return depth + 1;
}
```

```c
int ret;
void max(struct Node* node ,int depth){
    if(node == NULL) return ;
    ret = ret > depth ? ret : depth;
    for(int i = 0;i < node->numChildren;i++){
        if(node->children[i]) max(node->children[i],depth+1);
    }
}
int maxDepth(struct Node* root) {
    ret = 0;
    if(root == NULL) return ret;
    max(root,1);
    return ret;
}
```

## [111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

### 递归法

> 题目中说明:叶子节点是指没有子节点的节点，这句话的意思是 1 不是叶子节点
>
> 题目问的是到叶子节点的最短距离，所以所有返回结果为 1 当然不是这个结果
>
> 另外这道题的关键是搞清楚递归结束条件
>
> 叶子节点的定义是左孩子和右孩子都为 null 时叫做叶子节点
> 当 root 节点左右孩子都为空时，返回 1
> 当 root 节点左右孩子有一个为空时，返回不为空的孩子节点的深度
> 当 root 节点左右孩子都不为空时，返回左右孩子较小深度的节点值

```c
int minDepth(struct TreeNode* root){
    if(root == NULL) return 0;
    if(root->left == NULL &&root->right==NULL && root) return 1;//叶子节点返回1
    int m1 = minDepth(root -> left);//左
    int m2 = minDepth(root -> right);//右
    //中
    if(root -> left == NULL || root -> right == NULL) return m1 + m2 + 1;//有一个为0 ->左右子树有一个不存在，返回存在子树的深
    return fmin(m1,m2) + 1; 
}
```

```c
//前序递归
int ret;
void min(struct TreeNode*node , int depth){
    if(node->left==NULL&&node->right == NULL){
        ret = fmin(ret,depth);
        return ;
    }
    //中没有条件
    if(node->left) min(node->left,depth+1);//左
    if(node->right) min(node->right,depth+1);//右
}
int minDepth(struct TreeNode* root){
    if(root == NULL) return 0;
    int depth = 0;
    ret = INT_MAX;
    min(root,1);
    return ret;
}
```



### 层次遍历法

```c
int minDepth(struct TreeNode* root){
   if(root == NULL) return NULL;
   int depth = 0;
    struct TreeNode* queueDat[10000];
    int front = 0;
    int rear = 0;
    queueDat[rear++] = root;
    while(front != rear){
        int size = rear - front;
        depth++;
        for(int i = 0;i < size;i++){
            struct TreeNode* node = queueDat[front++];
            if(node -> left == NULL && node -> right == NULL) return depth;
            //退出条件：左右子树为空，即叶子节点跳出
            if(node -> left) queueDat[rear++] = node -> left;
            if(node -> right) queueDat[rear++] = node -> right;
        }
    }
    return 0;
}
```

## 

## [222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)

### 递归

```c
//前序递归
int sum(struct TreeNode * node){
    if(node == NULL) return 0;//空节点
    return sum(node->left)+sum(node->right)+1;
}
int countNodes(struct TreeNode* root){
    return sum(root);
}
```

### 层次遍历

```c
int countNodes(struct TreeNode* root){
    if(root == NULL) return 0;
    struct TreeNode* queue[10000000];
    int front = 0,rear = 0;
    int count = 0;
    queue[rear++] = root;
    while(rear != front) {
        int size = rear - front;
        count += size;
        for(int i = 0;i < size;i++){
            struct TreeNode* node = queue[front++];
            if(node->left) queue[rear++] = node->left;
            if(node->right) queue[rear++] = node->right;
        }
    }
    return count;
}
```

